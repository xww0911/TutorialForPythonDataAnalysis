{"./":{"url":"./","title":"Introduction","keywords":"","body":"python数据分析攻略 说道python,大家恐怕首先想到的就是数据科学.python有着一系列完善配套的数据科学相关工具. 包括通用的数据结构工具numpy,结构化数据分析表格工具pandas,科学计算算法包scipy以及数据可视化工具matplotlib 本文会详细介绍这几个工具的. Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-18 16:48:36 "},"matplotlib/":{"url":"matplotlib/","title":"可视化工具matplotlib","keywords":"","body":"python数据分析攻略 matplotlib和numpy一样,是事实上的python标准库 是被使用最多的二维绘图Python包。它不仅提供一个非常快捷的用python可视化数据的方法，而且提供了出版质量的多种格式图像。 不过遗憾的是pypy目前并不支持. matplotlib主要是一个绘图工具,大多数的数据科学工具都对他支持良好. 它体系庞大复杂,可以绘制各种常规图形,也可以绘制点线构成自定义的图形,可以是2d图形也可以画3d图形,可以绘制图片也可以构建简单动画,甚至于还有个模块爬取美股信息 本文将从多个角度介绍matplotlib Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-18 18:27:02 "},"matplotlib/matplotlib_config/matplotlib_config.html":{"url":"matplotlib/matplotlib_config/matplotlib_config.html","title":"matplotlib设置","keywords":"","body":"matplotlib的基本设置 绘图从来就是个很复杂的东西,各种样式各种设置非常复杂,不信的同学可以拿latex类比下. matplotlib设置方式可以分为三种: 使用内置的配置主题 临时设置 使用配置文件matplotlibrc import matplotlib.pyplot as plt import matplotlib import numpy as np %matplotlib inline 通常matplotlib在linux下的设置文件放在~/.config/matplotlib/下但也会有特殊,我们可以用下面的代码查看配置文件的位置 matplotlib.get_configdir() '/Users/huangsizhe/.matplotlib' 使用内置的配置主题 matplotlib内置了许多基本的设置主题可以通过matplotlib.pyplot.style.available查看 plt.style.available ['bmh', 'classic', 'dark_background', 'fivethirtyeight', 'ggplot', 'grayscale', 'seaborn-bright', 'seaborn-colorblind', 'seaborn-dark-palette', 'seaborn-dark', 'seaborn-darkgrid', 'seaborn-deep', 'seaborn-muted', 'seaborn-notebook', 'seaborn-paper', 'seaborn-pastel', 'seaborn-poster', 'seaborn-talk', 'seaborn-ticks', 'seaborn-white', 'seaborn-whitegrid', 'seaborn', 'animation_support', 'chinese_support'] 样式的用法有两种, 一种是全局使用,plt.style.use('seaborn-darkgrid') 设定好之后所有下面的图将都是这一样式 另一种是临时使用样式,可以使用plt.style.context结合with语句,构建上下文环境 我们来看看他们的效果大约是啥样 x=[1,2,3,4,5,6,7,8] y=[2,1,3,5,2,6,12,7] with plt.style.context(('seaborn-darkgrid')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('seaborn-notebook')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('classic')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('seaborn-ticks')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('grayscale')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('bmh')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('seaborn-talk')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('dark_background')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('ggplot')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('fivethirtyeight')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('seaborn-colorblind')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('seaborn-deep')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('seaborn-whitegrid')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('seaborn-bright')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('seaborn-poster')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('seaborn-muted')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('seaborn-paper')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('seaborn-white')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('seaborn-pastel')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('seaborn-dark')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('seaborn-dark-palette')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() 这些主题都是可以组合使用的 with plt.style.context(('fivethirtyeight','seaborn-whitegrid','seaborn-pastel')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() with plt.style.context(('seaborn-whitegrid','seaborn-pastel','fivethirtyeight')): plt.figure(figsize=(5,4)) plt.plot(x,y) plt.show() 可以看出,如果有冲突,后定义的会覆盖先定义的. 临时修改配置 matplotlib允许临时修改配置,使用的是matplotlib.rcParams matplotlib.rcParams['lines.linewidth'] = 2 matplotlib.rcParams['lines.color'] = 'r' 或者使用matplotlib.rc(group, **kwargs)来快速的为分组做设定 matplotlib.rc('lines', linewidth=2, color='r') 使用matplotlibrc文件全局的设置 matplotlib会以 本地->环境变量MATPLOTLIBRC/matplotlibrc指定位置->用户配置位置(linux:.config/matplotlib/matplotlibrc,other:.matplotlib/matplotlibrc),->matplotlib安装根目录/matplotlib/mpl-data/matplotlibrc 的顺序查找matplotlibrc,用它就可以配置需要的设置了,这个方法是全局默认加载的. 一份设置文档大约是这个样子,和python规则一样,#代表注释 ### MATPLOTLIBRC FORMAT # This is a sample matplotlib configuration file - you can find a copy # of it on your system in # site-packages/matplotlib/mpl-data/matplotlibrc. If you edit it # there, please note that it will be overwritten in your next install. # If you want to keep a permanent local copy that will not be # overwritten, place it in the following location: # unix/linux: # $HOME/.config/matplotlib/matplotlibrc or # $XDG_CONFIG_HOME/matplotlib/matplotlibrc (if $XDG_CONFIG_HOME is set) # other platforms: # $HOME/.matplotlib/matplotlibrc # # See http://matplotlib.org/users/customizing.html#the-matplotlibrc-file for # more details on the paths which are checked for the configuration file. # # This file is best viewed in a editor which supports python mode # syntax highlighting. Blank lines, or lines starting with a comment # symbol, are ignored, as are trailing comments. Other lines must # have the format # key : val # optional comment # # Colors: for the color values below, you can either use - a # matplotlib color string, such as r, k, or b - an rgb tuple, such as # (1.0, 0.5, 0.0) - a hex string, such as ff00ff - a scalar # grayscale intensity such as 0.75 - a legal html color name, e.g., red, # blue, darkslategray #### CONFIGURATION BEGINS HERE # The default backend; one of GTK GTKAgg GTKCairo GTK3Agg GTK3Cairo # MacOSX Qt4Agg Qt5Agg TkAgg WX WXAgg Agg Cairo GDK PS PDF SVG # Template. # You can also deploy your own backend outside of matplotlib by # referring to the module name (which must be in the PYTHONPATH) as # 'module://my_backend'. backend : tkagg # If you are using the Qt4Agg backend, you can choose here # to use the PyQt4 bindings or the newer PySide bindings to # the underlying Qt4 toolkit. #backend.qt4 : PyQt4 # PyQt4 | PySide # Note that this can be overridden by the environment variable # QT_API used by Enthought Tool Suite (ETS); valid values are # \"pyqt\" and \"pyside\". The \"pyqt\" setting has the side effect of # forcing the use of Version 2 API for QString and QVariant. # The port to use for the web server in the WebAgg backend. # webagg.port : 8888 # If webagg.port is unavailable, a number of other random ports will # be tried until one that is available is found. # webagg.port_retries : 50 # When True, open the webbrowser to the plot that is shown # webagg.open_in_browser : True # When True, the figures rendered in the nbagg backend are created with # a transparent background. # nbagg.transparent : False # if you are running pyplot inside a GUI and your backend choice # conflicts, we will automatically try to find a compatible one for # you if backend_fallback is True #backend_fallback: True #interactive : False #toolbar : toolbar2 # None | toolbar2 (\"classic\" is deprecated) #timezone : UTC # a pytz timezone string, e.g., US/Central or Europe/Paris # Where your matplotlib data lives if you installed to a non-default # location. This is where the matplotlib fonts, bitmaps, etc reside #datapath : /home/jdhunter/mpldata ### LINES # See http://matplotlib.org/api/artist_api.html#module-matplotlib.lines for more # information on line properties. #lines.linewidth : 1.5 # line width in points #lines.linestyle : - # solid line #lines.color : C0 # has no affect on plot(); see axes.prop_cycle #lines.marker : None # the default marker #lines.markeredgewidth : 1.0 # the line width around the marker symbol #lines.markersize : 6 # markersize, in points #lines.dash_joinstyle : miter # miter|round|bevel #lines.dash_capstyle : butt # butt|round|projecting #lines.solid_joinstyle : miter # miter|round|bevel #lines.solid_capstyle : projecting # butt|round|projecting #lines.antialiased : True # render lines in antialiased (no jaggies) # The three standard dash patterns. These are scaled by the linewidth. #lines.dashed_pattern : 2.8, 1.2 #lines.dashdot_pattern : 4.8, 1.2, 0.8, 1.2 #lines.dotted_pattern : 1.1, 1.1 #lines.scale_dashes : True #markers.fillstyle: full # full|left|right|bottom|top|none ### PATCHES # Patches are graphical objects that fill 2D space, like polygons or # circles. See # http://matplotlib.org/api/artist_api.html#module-matplotlib.patches # information on patch properties #patch.linewidth : 1 # edge width in points. #patch.facecolor : C0 #patch.edgecolor : black # if forced, or patch is not filled #patch.force_edgecolor : False # True to always use edgecolor #patch.antialiased : True # render patches in antialiased (no jaggies) ### HATCHES #hatch.color : k #hatch.linewidth : 1.0 ### Boxplot #boxplot.notch : False #boxplot.vertical : True #boxplot.whiskers : 1.5 #boxplot.bootstrap : None #boxplot.patchartist : False #boxplot.showmeans : False #boxplot.showcaps : True #boxplot.showbox : True #boxplot.showfliers : True #boxplot.meanline : False #boxplot.flierprops.color : 'k' #boxplot.flierprops.marker : 'o' #boxplot.flierprops.markerfacecolor : 'none' #boxplot.flierprops.markeredgecolor : 'k' #boxplot.flierprops.markersize : 6 #boxplot.flierprops.linestyle : 'none' #boxplot.flierprops.linewidth : 1.0 #boxplot.boxprops.color : 'k' #boxplot.boxprops.linewidth : 1.0 #boxplot.boxprops.linestyle : '-' #boxplot.whiskerprops.color : 'k' #boxplot.whiskerprops.linewidth : 1.0 #boxplot.whiskerprops.linestyle : '-' #boxplot.capprops.color : 'k' #boxplot.capprops.linewidth : 1.0 #boxplot.capprops.linestyle : '-' #boxplot.medianprops.color : 'C1' #boxplot.medianprops.linewidth : 1.0 #boxplot.medianprops.linestyle : '-' #boxplot.meanprops.color : 'C2' #boxplot.meanprops.marker : '^' #boxplot.meanprops.markerfacecolor : 'C2' #boxplot.meanprops.markeredgecolor : 'C2' #boxplot.meanprops.markersize : 6 #boxplot.meanprops.linestyle : 'none' #boxplot.meanprops.linewidth : 1.0 ### FONT # # font properties used by text.Text. See # http://matplotlib.org/api/font_manager_api.html for more # information on font properties. The 6 font properties used for font # matching are given below with their default values. # # The font.family property has five values: 'serif' (e.g., Times), # 'sans-serif' (e.g., Helvetica), 'cursive' (e.g., Zapf-Chancery), # 'fantasy' (e.g., Western), and 'monospace' (e.g., Courier). Each of # these font families has a default list of font names in decreasing # order of priority associated with them. When text.usetex is False, # font.family may also be one or more concrete font names. # # The font.style property has three values: normal (or roman), italic # or oblique. The oblique style will be used for italic, if it is not # present. # # The font.variant property has two values: normal or small-caps. For # TrueType fonts, which are scalable fonts, small-caps is equivalent # to using a font size of 'smaller', or about 83%% of the current font # size. # # The font.weight property has effectively 13 values: normal, bold, # bolder, lighter, 100, 200, 300, ..., 900. Normal is the same as # 400, and bold is 700. bolder and lighter are relative values with # respect to the current weight. # # The font.stretch property has 11 values: ultra-condensed, # extra-condensed, condensed, semi-condensed, normal, semi-expanded, # expanded, extra-expanded, ultra-expanded, wider, and narrower. This # property is not currently implemented. # # The font.size property is the default font size for text, given in pts. # 10 pt is the standard value. # #font.family : sans-serif #font.style : normal #font.variant : normal #font.weight : medium #font.stretch : normal # note that font.size controls default text sizes. To configure # special text sizes tick labels, axes, labels, title, etc, see the rc # settings for axes and ticks. Special text sizes can be defined # relative to font.size, using the following values: xx-small, x-small, # small, medium, large, x-large, xx-large, larger, or smaller #font.size : 10.0 #font.serif : DejaVu Serif, Bitstream Vera Serif, New Century Schoolbook, Century Schoolbook L, Utopia, ITC Bookman, Bookman, Nimbus Roman No9 L, Times New Roman, Times, Palatino, Charter, serif #font.sans-serif : DejaVu Sans, Bitstream Vera Sans, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serif #font.cursive : Apple Chancery, Textile, Zapf Chancery, Sand, Script MT, Felipa, cursive #font.fantasy : Comic Sans MS, Chicago, Charcoal, Impact, Western, Humor Sans, xkcd, fantasy #font.monospace : DejaVu Sans Mono, Bitstream Vera Sans Mono, Andale Mono, Nimbus Mono L, Courier New, Courier, Fixed, Terminal, monospace ### TEXT # text properties used by text.Text. See # http://matplotlib.org/api/artist_api.html#module-matplotlib.text for more # information on text properties #text.color : black ### LaTeX customizations. See http://wiki.scipy.org/Cookbook/Matplotlib/UsingTex #text.usetex : False # use latex for all text handling. The following fonts # are supported through the usual rc parameter settings: # new century schoolbook, bookman, times, palatino, # zapf chancery, charter, serif, sans-serif, helvetica, # avant garde, courier, monospace, computer modern roman, # computer modern sans serif, computer modern typewriter # If another font is desired which can loaded using the # LaTeX \\usepackage command, please inquire at the # matplotlib mailing list #text.latex.unicode : False # use \"ucs\" and \"inputenc\" LaTeX packages for handling # unicode strings. #text.latex.preamble : # IMPROPER USE OF THIS FEATURE WILL LEAD TO LATEX FAILURES # AND IS THEREFORE UNSUPPORTED. PLEASE DO NOT ASK FOR HELP # IF THIS FEATURE DOES NOT DO WHAT YOU EXPECT IT TO. # preamble is a comma separated list of LaTeX statements # that are included in the LaTeX document preamble. # An example: # text.latex.preamble : \\usepackage{bm},\\usepackage{euler} # The following packages are always loaded with usetex, so # beware of package collisions: color, geometry, graphicx, # type1cm, textcomp. Adobe Postscript (PSSNFS) font packages # may also be loaded, depending on your font settings #text.dvipnghack : None # some versions of dvipng don't handle alpha # channel properly. Use True to correct # and flush ~/.matplotlib/tex.cache # before testing and False to force # correction off. None will try and # guess based on your dvipng version #text.hinting : auto # May be one of the following: # 'none': Perform no hinting # 'auto': Use FreeType's autohinter # 'native': Use the hinting information in the # font file, if available, and if your # FreeType library supports it # 'either': Use the native hinting information, # or the autohinter if none is available. # For backward compatibility, this value may also be # True === 'auto' or False === 'none'. #text.hinting_factor : 8 # Specifies the amount of softness for hinting in the # horizontal direction. A value of 1 will hint to full # pixels. A value of 2 will hint to half pixels etc. #text.antialiased : True # If True (default), the text will be antialiased. # This only affects the Agg backend. # The following settings allow you to select the fonts in math mode. # They map from a TeX font name to a fontconfig font pattern. # These settings are only used if mathtext.fontset is 'custom'. # Note that this \"custom\" mode is unsupported and may go away in the # future. #mathtext.cal : cursive #mathtext.rm : serif #mathtext.tt : monospace #mathtext.it : serif:italic #mathtext.bf : serif:bold #mathtext.sf : sans #mathtext.fontset : dejavusans # Should be 'dejavusans' (default), # 'dejavuserif', 'cm' (Computer Modern), 'stix', # 'stixsans' or 'custom' #mathtext.fallback_to_cm : True # When True, use symbols from the Computer Modern # fonts when a symbol can not be found in one of # the custom math fonts. #mathtext.default : it # The default font to use for math. # Can be any of the LaTeX font names, including # the special name \"regular\" for the same font # used in regular text. ### AXES # default face and edge color, default tick sizes, # default fontsizes for ticklabels, and so on. See # http://matplotlib.org/api/axes_api.html#module-matplotlib.axes #axes.facecolor : white # axes background color #axes.edgecolor : black # axes edge color #axes.linewidth : 0.8 # edge linewidth #axes.grid : False # display grid or not #axes.titlesize : large # fontsize of the axes title #axes.titlepad : 4.0 # pad between axes and title in points #axes.labelsize : medium # fontsize of the x any y labels #axes.labelpad : 4.0 # space between label and axis #axes.labelweight : normal # weight of the x and y labels #axes.labelcolor : black #axes.axisbelow : 'line' # draw axis gridlines and ticks below # patches (True); above patches but below # lines ('line'); or above all (False) #axes.formatter.limits : -7, 7 # use scientific notation if log10 # of the axis range is smaller than the # first or larger than the second #axes.formatter.use_locale : False # When True, format tick labels # according to the user's locale. # For example, use ',' as a decimal # separator in the fr_FR locale. #axes.formatter.use_mathtext : False # When True, use mathtext for scientific # notation. #axes.formatter.useoffset : True # If True, the tick label formatter # will default to labeling ticks relative # to an offset when the data range is # small compared to the minimum absolute # value of the data. #axes.formatter.offset_threshold : 4 # When useoffset is True, the offset # will be used when it can remove # at least this number of significant # digits from tick labels. # axes.spines.left : True # display axis spines # axes.spines.bottom : True # axes.spines.top : True # axes.spines.right : True #axes.unicode_minus : True # use unicode for the minus symbol # rather than hyphen. See # http://en.wikipedia.org/wiki/Plus_and_minus_signs#Character_codes #axes.prop_cycle : cycler('color', # ['1f77b4', 'ff7f0e', '2ca02c', 'd62728', # '9467bd', '8c564b', 'e377c2', '7f7f7f', # 'bcbd22', '17becf']) # color cycle for plot lines # as list of string colorspecs: # single letter, long name, or # web-style hex #axes.autolimit_mode : data # How to scale axes limits to the data. # Use \"data\" to use data limits, plus some margin # Use \"round_number\" move to the nearest \"round\" number #axes.xmargin : .05 # x margin. See `axes.Axes.margins` #axes.ymargin : .05 # y margin See `axes.Axes.margins` #polaraxes.grid : True # display grid on polar axes #axes3d.grid : True # display grid on 3d axes ### DATES # These control the default format strings used in AutoDateFormatter. # Any valid format datetime format string can be used (see the python # `datetime` for details). For example using '%%x' will use the locale date representation # '%%X' will use the locale time representation and '%%c' will use the full locale datetime # representation. # These values map to the scales: # {'year': 365, 'month': 30, 'day': 1, 'hour': 1/24, 'minute': 1 / (24 * 60)} # date.autoformatter.year : %Y # date.autoformatter.month : %Y-%m # date.autoformatter.day : %Y-%m-%d # date.autoformatter.hour : %H:%M # date.autoformatter.minute : %H:%M:%S # date.autoformatter.second : %H:%M:%S # date.autoformatter.microsecond : %H:%M:%S.%f ### TICKS # see http://matplotlib.org/api/axis_api.html#matplotlib.axis.Tick #xtick.top : False # draw ticks on the top side #xtick.bottom : True # draw ticks on the bottom side #xtick.major.size : 3.5 # major tick size in points #xtick.minor.size : 2 # minor tick size in points #xtick.major.width : 0.8 # major tick width in points #xtick.minor.width : 0.6 # minor tick width in points #xtick.major.pad : 3.5 # distance to major tick label in points #xtick.minor.pad : 3.4 # distance to the minor tick label in points #xtick.color : k # color of the tick labels #xtick.labelsize : medium # fontsize of the tick labels #xtick.direction : out # direction: in, out, or inout #xtick.minor.visible : False # visibility of minor ticks on x-axis #xtick.major.top : True # draw x axis top major ticks #xtick.major.bottom : True # draw x axis bottom major ticks #xtick.minor.top : True # draw x axis top minor ticks #xtick.minor.bottom : True # draw x axis bottom minor ticks #ytick.left : True # draw ticks on the left side #ytick.right : False # draw ticks on the right side #ytick.major.size : 3.5 # major tick size in points #ytick.minor.size : 2 # minor tick size in points #ytick.major.width : 0.8 # major tick width in points #ytick.minor.width : 0.6 # minor tick width in points #ytick.major.pad : 3.5 # distance to major tick label in points #ytick.minor.pad : 3.4 # distance to the minor tick label in points #ytick.color : k # color of the tick labels #ytick.labelsize : medium # fontsize of the tick labels #ytick.direction : out # direction: in, out, or inout #ytick.minor.visible : False # visibility of minor ticks on y-axis #xtick.major.left : True # draw y axis left major ticks #xtick.major.right : True # draw y axis right major ticks #xtick.minor.left : True # draw y axis left minor ticks #xtick.minor.right : True # draw y axis right minor ticks ### GRIDS #grid.color : b0b0b0 # grid color #grid.linestyle : - # solid #grid.linewidth : 0.8 # in points #grid.alpha : 1.0 # transparency, between 0.0 and 1.0 ### Legend #legend.loc : best #legend.frameon : True # if True, draw the legend on a background patch #legend.framealpha : 0.8 # legend patch transparency #legend.facecolor : inherit # inherit from axes.facecolor; or color spec #legend.edgecolor : 0.8 # background patch boundary color #legend.fancybox : True # if True, use a rounded box for the # legend background, else a rectangle #legend.shadow : False # if True, give background a shadow effect #legend.numpoints : 1 # the number of marker points in the legend line #legend.scatterpoints : 1 # number of scatter points #legend.markerscale : 1.0 # the relative size of legend markers vs. original #legend.fontsize : medium # Dimensions as fraction of fontsize: #legend.borderpad : 0.4 # border whitespace #legend.labelspacing : 0.5 # the vertical space between the legend entries #legend.handlelength : 2.0 # the length of the legend lines #legend.handleheight : 0.7 # the height of the legend handle #legend.handletextpad : 0.8 # the space between the legend line and legend text #legend.borderaxespad : 0.5 # the border between the axes and legend edge #legend.columnspacing : 2.0 # column separation ### FIGURE # See http://matplotlib.org/api/figure_api.html#matplotlib.figure.Figure #figure.titlesize : large # size of the figure title (Figure.suptitle()) #figure.titleweight : normal # weight of the figure title #figure.figsize : 6.4, 4.8 # figure size in inches #figure.dpi : 100 # figure dots per inch #figure.facecolor : white # figure facecolor; 0.75 is scalar gray #figure.edgecolor : white # figure edgecolor #figure.autolayout : False # When True, automatically adjust subplot # parameters to make the plot fit the figure #figure.max_open_warning : 20 # The maximum number of figures to open through # the pyplot interface before emitting a warning. # If less than one this feature is disabled. # The figure subplot parameters. All dimensions are a fraction of the #figure.subplot.left : 0.125 # the left side of the subplots of the figure #figure.subplot.right : 0.9 # the right side of the subplots of the figure #figure.subplot.bottom : 0.11 # the bottom of the subplots of the figure #figure.subplot.top : 0.88 # the top of the subplots of the figure #figure.subplot.wspace : 0.2 # the amount of width reserved for blank space between subplots, # expressed as a fraction of the average axis width #figure.subplot.hspace : 0.2 # the amount of height reserved for white space between subplots, # expressed as a fraction of the average axis height ### IMAGES #image.aspect : equal # equal | auto | a number #image.interpolation : nearest # see help(imshow) for options #image.cmap : viridis # A colormap name, gray etc... #image.lut : 256 # the size of the colormap lookup table #image.origin : upper # lower | upper #image.resample : True #image.composite_image : True # When True, all the images on a set of axes are # combined into a single composite image before # saving a figure as a vector graphics file, # such as a PDF. ### CONTOUR PLOTS #contour.negative_linestyle : dashed # dashed | solid #contour.corner_mask : True # True | False | legacy ### ERRORBAR PLOTS #errorbar.capsize : 0 # length of end cap on error bars in pixels ### HISTOGRAM PLOTS #hist.bins : 10 # The default number of histogram bins. # If Numpy 1.11 or later is # installed, may also be `auto` ### SCATTER PLOTS #scatter.marker : o # The default marker type for scatter plots. ### Agg rendering ### Warning: experimental, 2008/10/10 #agg.path.chunksize : 0 # 0 to disable; values in the range # 10000 to 100000 can improve speed slightly # and prevent an Agg rendering failure # when plotting very large data sets, # especially if they are very gappy. # It may cause minor artifacts, though. # A value of 20000 is probably a good # starting point. ### SAVING FIGURES #path.simplify : True # When True, simplify paths by removing \"invisible\" # points to reduce file size and increase rendering # speed #path.simplify_threshold : 0.1 # The threshold of similarity below which # vertices will be removed in the simplification # process #path.snap : True # When True, rectilinear axis-aligned paths will be snapped to # the nearest pixel when certain criteria are met. When False, # paths will never be snapped. #path.sketch : None # May be none, or a 3-tuple of the form (scale, length, # randomness). # *scale* is the amplitude of the wiggle # perpendicular to the line (in pixels). *length* # is the length of the wiggle along the line (in # pixels). *randomness* is the factor by which # the length is randomly scaled. # the default savefig params can be different from the display params # e.g., you may want a higher resolution, or to make the figure # background white #savefig.dpi : figure # figure dots per inch or 'figure' #savefig.facecolor : white # figure facecolor when saving #savefig.edgecolor : white # figure edgecolor when saving #savefig.format : png # png, ps, pdf, svg #savefig.bbox : standard # 'tight' or 'standard'. # 'tight' is incompatible with pipe-based animation # backends but will workd with temporary file based ones: # e.g. setting animation.writer to ffmpeg will not work, # use ffmpeg_file instead #savefig.pad_inches : 0.1 # Padding to be used when bbox is set to 'tight' #savefig.jpeg_quality: 95 # when a jpeg is saved, the default quality parameter. #savefig.directory : ~ # default directory in savefig dialog box, # leave empty to always use current working directory #savefig.transparent : False # setting that controls whether figures are saved with a # transparent background by default # tk backend params #tk.window_focus : False # Maintain shell focus for TkAgg # ps backend params #ps.papersize : letter # auto, letter, legal, ledger, A0-A10, B0-B10 #ps.useafm : False # use of afm fonts, results in small files #ps.usedistiller : False # can be: None, ghostscript or xpdf # Experimental: may produce smaller files. # xpdf intended for production of publication quality files, # but requires ghostscript, xpdf and ps2eps #ps.distiller.res : 6000 # dpi #ps.fonttype : 3 # Output Type 3 (Type3) or Type 42 (TrueType) # pdf backend params #pdf.compression : 6 # integer from 0 to 9 # 0 disables compression (good for debugging) #pdf.fonttype : 3 # Output Type 3 (Type3) or Type 42 (TrueType) # svg backend params #svg.image_inline : True # write raster image data directly into the svg file #svg.fonttype : 'path' # How to handle SVG fonts: # 'none': Assume fonts are installed on the machine where the SVG will be viewed. # 'path': Embed characters as paths -- supported by most SVG renderers # 'svgfont': Embed characters as SVG fonts -- supported only by Chrome, # Opera and Safari #svg.hashsalt : None # if not None, use this string as hash salt # instead of uuid4 # docstring params #docstring.hardcopy = False # set this when you want to generate hardcopy docstring # Set the verbose flags. This controls how much information # matplotlib gives you at runtime and where it goes. The verbosity # levels are: silent, helpful, debug, debug-annoying. Any level is # inclusive of all the levels below it. If your setting is \"debug\", # you'll get all the debug and helpful messages. When submitting # problems to the mailing-list, please set verbose to \"helpful\" or \"debug\" # and paste the output into your report. # # The \"fileo\" gives the destination for any calls to verbose.report. # These objects can a filename, or a filehandle like sys.stdout. # # You can override the rc default verbosity from the command line by # giving the flags --verbose-LEVEL where LEVEL is one of the legal # levels, e.g., --verbose-helpful. # # You can access the verbose instance in your code # from matplotlib import verbose. #verbose.level : silent # one of silent, helpful, debug, debug-annoying #verbose.fileo : sys.stdout # a log filename, sys.stdout or sys.stderr # Event keys to interact with figures/plots via keyboard. # Customize these settings according to your needs. # Leave the field(s) empty if you don't need a key-map. (i.e., fullscreen : '') #keymap.fullscreen : f # toggling #keymap.home : h, r, home # home or reset mnemonic #keymap.back : left, c, backspace # forward / backward keys to enable #keymap.forward : right, v # left handed quick navigation #keymap.pan : p # pan mnemonic #keymap.zoom : o # zoom mnemonic #keymap.save : s # saving current figure #keymap.quit : ctrl+w, cmd+w # close the current figure #keymap.grid : g # switching on/off a grid in current axes #keymap.yscale : l # toggle scaling of y-axes ('log'/'linear') #keymap.xscale : L, k # toggle scaling of x-axes ('log'/'linear') #keymap.all_axes : a # enable all axes # Control location of examples data files #examples.directory : '' # directory to look in for custom installation ###ANIMATION settings #animation.html : 'none' # How to display the animation as HTML in # the IPython notebook. 'html5' uses # HTML5 video tag. #animation.writer : ffmpeg # MovieWriter 'backend' to use #animation.codec : h264 # Codec to use for writing movie #animation.bitrate: -1 # Controls size/quality tradeoff for movie. # -1 implies let utility auto-determine #animation.frame_format: 'png' # Controls frame format used by temp files #animation.ffmpeg_path: 'ffmpeg' # Path to ffmpeg binary. Without full path # $PATH is searched #animation.ffmpeg_args: '' # Additional arguments to pass to ffmpeg #animation.avconv_path: 'avconv' # Path to avconv binary. Without full path # $PATH is searched #animation.avconv_args: '' # Additional arguments to pass to avconv #animation.mencoder_path: 'mencoder' # Path to mencoder binary. Without full path # $PATH is searched #animation.mencoder_args: '' # Additional arguments to pass to mencoder #animation.convert_path: 'convert' # Path to ImageMagick's convert binary. # On Windows use the full path since convert # is also the name of a system tool. 自定义主题(支持中文字体) 我们当然可以自己定义自己的主题,他的内容和matplotlibrc一样,但以.mplstyle作为后缀,自定义的主题放在mpl_configdir/stylelib下就可以被识别,比如我们定义一个专用于可以显示中文的主题chinese_support.mplstyle 第一步,下载字体,我们使用[微软雅黑],下载好后放在自己的设置文件夹matplotlib安装根目录/matplotlib/mpl-data/下的fonts/ttf文件夹中(这步如果已经有字体文件可以省略) 第二步,在你的设置文件夹下的stylelib文件夹下(没有就自己创建)写下 font.family : LiHei ProLi,Song Pro,Microsoft YaHei, sans-serif 为了跨平台,可以把Microsoft YaHei放到前面,但个人觉得没苹果的字体好看,就算了 第三步,删除fontList.cache文件然后重启即可 字体文件可以在这里下载,本文用到的两个配置文件在这里可以下载: chinese_support.mplstyle animation_support.mplstyle 查看自己有哪些字体可以使用如下命令 from matplotlib.font_manager import FontManager import subprocess fm = FontManager() mat_fonts = set(f.name for f in fm.ttflist) mat_fonts {'.Keyboard', '.LastResort', 'Andale Mono', 'Apple Braille', 'Apple Chancery', 'AppleGothic', 'AppleMyungjo', 'Arial', 'Arial Black', 'Arial Narrow', 'Arial Rounded MT Bold', 'Arial Unicode MS', 'Ayuthaya', 'Big Caslon', 'Bodoni 72 Smallcaps', 'Bodoni Ornaments', 'Bradley Hand', 'Brush Script MT', 'Chalkduster', 'Comic Sans MS', 'Courier New', 'DIN Alternate', 'DIN Condensed', 'DejaVu Sans', 'DejaVu Sans Display', 'DejaVu Sans Mono', 'DejaVu Serif', 'DejaVu Serif Display', 'Diwan Thuluth', 'Farisi', 'Georgia', 'GungSeo', 'Gurmukhi MT', 'HeadLineA', 'Herculanum', 'Hoefler Text', 'Impact', 'InaiMathi', 'Khmer Sangam MN', 'Kokonor', 'Krungthep', 'Lao Sangam MN', 'LiHei Pro', 'LiSong Pro', 'Luminari', 'Microsoft Sans Serif', 'Mishafi', 'Mishafi Gold', 'Osaka', 'PCMyungjo', 'PilGi', 'Plantagenet Cherokee', 'STFangsong', 'STHeiti', 'STIXGeneral', 'STIXIntegralsD', 'STIXIntegralsSm', 'STIXIntegralsUp', 'STIXIntegralsUpD', 'STIXIntegralsUpSm', 'STIXNonUnicode', 'STIXSizeFiveSym', 'STIXSizeFourSym', 'STIXSizeOneSym', 'STIXSizeThreeSym', 'STIXSizeTwoSym', 'STIXVariants', 'Sathu', 'SignPainter', 'Silom', 'Skia', 'Symbol', 'System Font', 'Tahoma', 'Times New Roman', 'Trattatello', 'Trebuchet MS', 'Verdana', 'Wawati SC', 'Wawati TC', 'Webdings', 'Weibei SC', 'Weibei TC', 'Wingdings', 'Wingdings 2', 'Wingdings 3', 'YuGothic', 'Yuppy SC', 'Yuppy TC', 'Zapf Dingbats', 'Zapfino', 'cmb10', 'cmex10', 'cmmi10', 'cmr10', 'cmss10', 'cmsy10', 'cmtt10'} X = np.linspace(-np.pi, np.pi, 256,endpoint=True) C,S = np.cos(X), np.sin(X) plt.figure(figsize=(8,5), dpi=80)#设置图片大小和dpi plt.subplot(111) plt.plot(X, C, color=\"blue\", linewidth=2.5, linestyle=\"-\",label=u\"余弦\") plt.plot(X, S, color=\"red\", linewidth=2.5, linestyle=\"-\",label=u\"正弦\") plt.legend(loc='upper left')#图例位置 plt.xlim(X.min()*1.1, X.max()*1.1)#边界扩大1.1倍 plt.ylim(C.min()*1.1,C.max()*1.1)#边界扩大1.1倍 plt.xticks( [-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r'$-\\pi$',r'$-\\pi / 2$',r'$0$',r'$\\pi / 2$',r'$\\pi$'])#设置x轴记号标签,用latex符号替代具体数 plt.yticks([-1, 0, +1])#设置y轴记号标签 ax = plt.gca()#脊柱 ax.spines['right'].set_color('none')#右脊柱设为无色 ax.spines['top'].set_color('none')#上脊柱设为无色 ax.xaxis.set_ticks_position('bottom')#下脊柱设定位置 ax.spines['bottom'].set_position(('data',0)) ax.yaxis.set_ticks_position('left')#左脊柱设定位置 ax.spines['left'].set_position(('data',0)) plt.show() plt.style.use('chinese_support') X = np.linspace(-np.pi, np.pi, 256,endpoint=True) C,S = np.cos(X), np.sin(X) plt.figure(figsize=(8,5), dpi=80)#设置图片大小和dpi plt.subplot(111) plt.plot(X, C, color=\"blue\", linewidth=2.5, linestyle=\"-\",label=u\"余弦\") plt.plot(X, S, color=\"red\", linewidth=2.5, linestyle=\"-\",label=u\"正弦\") plt.legend(loc='upper left')#图例位置 plt.xlim(X.min()*1.1, X.max()*1.1)#边界扩大1.1倍 plt.ylim(C.min()*1.1,C.max()*1.1)#边界扩大1.1倍 plt.xticks( [-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r'$-\\pi$',r'$-\\pi / 2$',r'$0$',r'$\\pi / 2$',r'$\\pi$'])#设置x轴记号标签,用latex符号替代具体数 plt.yticks([-1, 0, +1])#设置y轴记号标签 ax = plt.gca()#脊柱 ax.spines['right'].set_color('none')#右脊柱设为无色 ax.spines['top'].set_color('none')#上脊柱设为无色 ax.xaxis.set_ticks_position('bottom')#下脊柱设定位置 ax.spines['bottom'].set_position(('data',0)) ax.yaxis.set_ticks_position('left')#左脊柱设定位置 ax.spines['left'].set_position(('data',0)) plt.show() matplotlib 对notebook的特殊支持 matplotlib提供了一个backend为jupyter notebook 提供了控件支持 from __future__ import print_function from imp import reload import matplotlib reload(matplotlib) matplotlib.use('nbagg') import matplotlib.backends.backend_nbagg reload(matplotlib.backends.backend_nbagg) 非交互模式 import matplotlib.backends.backend_webagg_core reload(matplotlib.backends.backend_webagg_core) import matplotlib.pyplot as plt plt.interactive(False) fig1 = plt.figure() plt.plot(range(10)) plt.show() 定义了第一张图后,后面的定义就可以不再使用plt.figure() plt.plot([3, 2, 1]) plt.show() 我们可以用connection_info()查看每张图片的ui状态 print(matplotlib.backends.backend_nbagg.connection_info()) Figure 1 - Figure 1 Figure 2 - Figure 2 Figures pending show: 0 也可以关闭一副图的ui plt.close(fig1) 在非交互模式下没有plt.show就不会显示 plt.plot(range(10)) [] 显示以前创建的图 plt.show() plt.figure() plt.plot(range(5)) plt.show() 交互模式 使用plt.interactive(True)开启交互模式,交互模式下不需要show就可以显示图片 plt.interactive(True) plt.figure() plt.plot([3, 2, 1]) [] 后续行应添加到现有图形，而不是创建一个新的图形。 plt.plot(range(3)) [] 在交互模式下调用connection_info不应显示任何未决数字 print(matplotlib.backends.backend_nbagg.connection_info()) Figure 2 - Figure 2 Figure 3 - Figure 3 Figure 4 - Figure 4 Figure 5 - Figure 5 这种模式用来调试不错,并不适合用来做图 plt.interactive(False) 多个显示 plt.gcf().canvas.manager.reshow() 动画 import matplotlib.animation as animation import numpy as np fig, ax = plt.subplots() x = np.arange(0, 2*np.pi, 0.01) # x-array line, = ax.plot(x, np.sin(x)) def animate(i): line.set_ydata(np.sin(x+i/10.0)) # update the data return line, #Init only required for blitting to give a clean slate. def init(): line.set_ydata(np.ma.array(x, mask=True)) return line, ani = animation.FuncAnimation(fig, animate, np.arange(1, 200), init_func=init, interval=32., blit=True) plt.show() 绑定事件动作 按任何键盘键或鼠标按钮（或滚动）应该在图形有焦点时循环线条线。该图在创建时应默认具有焦点，并通过单击画布重新获得。单击图形外的任何位置都应该释放焦点，但将鼠标移出图形不应该释放焦点。 import itertools fig, ax = plt.subplots() x = np.linspace(0,10,10000) y = np.sin(x) ln, = ax.plot(x,y) evt = [] colors = iter(itertools.cycle(['r', 'g', 'b', 'k', 'c'])) def on_event(event): if event.name.startswith('key'): fig.suptitle('%s: %s' % (event.name, event.key)) elif event.name == 'scroll_event': fig.suptitle('%s: %s' % (event.name, event.step)) else: fig.suptitle('%s: %s' % (event.name, event.button)) evt.append(event) ln.set_color(next(colors)) fig.canvas.draw() fig.canvas.draw_idle() fig.canvas.mpl_connect('button_press_event', on_event) fig.canvas.mpl_connect('button_release_event', on_event) fig.canvas.mpl_connect('scroll_event', on_event) fig.canvas.mpl_connect('key_press_event', on_event) fig.canvas.mpl_connect('key_release_event', on_event) plt.show() 计时器 import time fig, ax = plt.subplots() text = ax.text(0.5, 0.5, '', ha='center') def update(text): text.set(text=time.ctime()) text.axes.figure.canvas.draw() timer = fig.canvas.new_timer(500, [(update, [text], {})]) timer.start() plt.show() Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-18 18:30:24 "},"matplotlib/pyplot/pyplot.html":{"url":"matplotlib/pyplot/pyplot.html","title":"pyplot","keywords":"","body":"绘图工具pyplot matplotlib.pylot是matplotlib的绘图工具 我们将会由一个绘制sin(x)曲线的例子开始,由简单到复杂的学习这个库 最简单的实现 最基本的函数就是plt.plot()了,它会产生一个图形, import matplotlib.pyplot as plt import pylab %matplotlib inline import numpy as np plt.style.use('chinese_support') X = np.linspace(-np.pi, np.pi, 256,endpoint=True) C,S = np.cos(X), np.sin(X) plt.plot(X,C);plt.plot(X,S) [] 修改一些设置 plot接收参数,可以使用color指定线的颜色,用linewidth指定线条粗细,linestyle指定线条形状 plt.figure(figsize=(10,6), dpi=80)#设置图片大小和dpi plt.plot(X, C, color=\"blue\", linewidth=2.5, linestyle=\"-\");plt.plot(X, S, color=\"red\", linewidth=2.5, linestyle=\"--\") [] 边界扩大 我们可以i为plt对象绑定xlim和ylim来指定坐标轴的范围 plt.figure(figsize=(8,5), dpi=80)#设置图片大小和dpi plt.subplot(111) plt.plot(X, C, color=\"blue\", linewidth=2.5, linestyle=\"-\") plt.plot(X, S, color=\"red\", linewidth=2.5, linestyle=\"-\") plt.xlim(X.min()*1.1, X.max()*1.1)#边界扩大1.1倍 plt.ylim(C.min()*1.1,C.max()*1.1)#边界扩大1.1倍 plt.show() 设置y轴记号标签 xtick和ytick则是可以接收一个序列来确定刻度 plt.figure(figsize=(8,5), dpi=80)#设置图片大小和dpi plt.subplot(111) plt.plot(X, C, color=\"blue\", linewidth=2.5, linestyle=\"-\") plt.plot(X, S, color=\"red\", linewidth=2.5, linestyle=\"-\") plt.xlim(X.min()*1.1, X.max()*1.1)#边界扩大1.1倍 plt.ylim(C.min()*1.1,C.max()*1.1)#边界扩大1.1倍 plt.xticks( [-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r'$-\\pi$',r'$-\\pi / 2$',r'$0$',r'$\\pi / 2$',r'$\\pi$'])#设置x轴记号标签,用latex符号替代具体数 plt.yticks([-1, 0, +1])#设置y轴记号标签 plt.show() 移动脊柱 实际上每幅图有四条脊柱（上下左右），为了将脊柱放在图的中间，我们必须将其中的两条（上和右）设置为无色，然后调整剩下的两条到合适的位置——数据空间的 0 点。 脊柱使用对象gca来操作 它有 .spines选择'right','top','bottom','left'来确定要操作的是哪条脊柱 .set_color设置颜色 .set_position设定位置 plt.figure(figsize=(8,5), dpi=80)#设置图片大小和dpi plt.subplot(111) plt.plot(X, C, color=\"blue\", linewidth=2.5, linestyle=\"-\") plt.plot(X, S, color=\"red\", linewidth=2.5, linestyle=\"-\") plt.xlim(X.min()*1.1, X.max()*1.1)#边界扩大1.1倍 plt.ylim(C.min()*1.1,C.max()*1.1)#边界扩大1.1倍 plt.xticks( [-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r'$-\\pi$',r'$-\\pi / 2$',r'$0$',r'$\\pi / 2$',r'$\\pi$'])#设置x轴记号标签,用latex符号替代具体数 plt.yticks([-1, 0, +1])#设置y轴记号标签 ax = plt.gca()#脊柱 ax.spines['right'].set_color('none')#右脊柱设为无色 ax.spines['top'].set_color('none')#上脊柱设为无色 ax.xaxis.set_ticks_position('bottom')#下脊柱设定位置 ax.spines['bottom'].set_position(('data',0)) ax.yaxis.set_ticks_position('left')#左脊柱设定位置 ax.spines['left'].set_position(('data',0)) plt.show() 图例 plt.legend(loc=)可以用来初始化图例位置 plt.figure(figsize=(8,5), dpi=80)#设置图片大小和dpi plt.subplot(111) plt.plot(X, C, color=\"blue\", linewidth=2.5, linestyle=\"-\",label=\"cosine\") plt.plot(X, S, color=\"red\", linewidth=2.5, linestyle=\"-\",label=\"sine\") plt.legend(loc='upper left')#图例位置 plt.xlim(X.min()*1.1, X.max()*1.1)#边界扩大1.1倍 plt.ylim(C.min()*1.1,C.max()*1.1)#边界扩大1.1倍 plt.xticks( [-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r'$-\\pi$',r'$-\\pi / 2$',r'$0$',r'$\\pi / 2$',r'$\\pi$'])#设置x轴记号标签,用latex符号替代具体数 plt.yticks([-1, 0, +1])#设置y轴记号标签 ax = plt.gca()#脊柱 ax.spines['right'].set_color('none')#右脊柱设为无色 ax.spines['top'].set_color('none')#上脊柱设为无色 ax.xaxis.set_ticks_position('bottom')#下脊柱设定位置 ax.spines['bottom'].set_position(('data',0)) ax.yaxis.set_ticks_position('left')#左脊柱设定位置 ax.spines['left'].set_position(('data',0)) plt.show() 给一些特殊点做注释 我们希望在 $2\\pi/3$ 的位置给两条函数曲线加上一个注释。首先，我们在对应的函数图像位置上画一个点；然后，向横轴引一条垂线，以虚线标记；最后，写上标签。 plt.text可以在图上指定位置配上文字 plt.annotate可以用来画出图片上的说明文字 plt.plot用来画直线 plt.scatter 可以用来画交点 plt.figure(figsize=(8,5), dpi=80)#设置图片大小和dpi plt.subplot(111) plt.text(0.25, 0.75, r'$cos(x)$') plt.text(1.25, 0.75, r'$sin(x)$') plt.plot(X, C, color=\"blue\", linewidth=2.5, linestyle=\"-\",label=\"cosine\") plt.plot(X, S, color=\"red\", linewidth=2.5, linestyle=\"-\",label=\"sine\") plt.legend(loc='upper left')#图例位置 plt.xlim(X.min()*1.1, X.max()*1.1)#边界扩大1.1倍 plt.ylim(C.min()*1.1,C.max()*1.1)#边界扩大1.1倍 plt.xticks( [-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r'$-\\pi$',r'$-\\pi / 2$',r'$0$',r'$\\pi / 2$',r'$\\pi$'])#设置x轴记号标签,用latex符号替代具体数 plt.yticks([-1, 0, +1])#设置y轴记号标签 ax = plt.gca()#脊柱 ax.spines['right'].set_color('none')#右脊柱设为无色 ax.spines['top'].set_color('none')#上脊柱设为无色 ax.xaxis.set_ticks_position('bottom')#下脊柱设定位置 ax.spines['bottom'].set_position(('data',0)) ax.yaxis.set_ticks_position('left')#左脊柱设定位置 ax.spines['left'].set_position(('data',0)) t = 2*np.pi/3 #特殊点x轴位置 plt.plot([t,t],[0,np.cos(t)], color ='blue', linewidth=2.5, linestyle=\"--\")#竖线从0到与cos(t)交点,蓝色虚线 plt.scatter([t,],[np.cos(t),], 50, color ='blue')# 画交点 plt.annotate(r'$\\sin(\\frac{2\\pi}{3})=\\frac{\\sqrt{3}}{2}$', xy=(t, np.sin(t)), xycoords='data', xytext=(+10, +30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=.2\"))#指出交点并说明公式 plt.plot([t,t],[0,np.sin(t)], color ='red', linewidth=2.5, linestyle=\"--\")#竖线从0到与sin(t)交点,红色虚线 plt.scatter([t,],[np.sin(t),], 50, color ='red')# 画交点 plt.annotate(r'$\\cos(\\frac{2\\pi}{3})=-\\frac{1}{2}$', xy=(t, np.cos(t)), xycoords='data', xytext=(-90, -50), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=.2\"))#指出交点并说明公式 plt.show() 精益求精 坐标轴上的记号标签被曲线挡住了，作为强迫症患者这是不能忍的。我们可以把它们放大，然后添加一个白色的半透明底色。这样可以保证标签和曲线同时可见。 并且我们给图片加上格子 plt.figure(figsize=(8,5), dpi=80)#设置图片大小和dpi plt.subplot(111) plt.plot(X, C, color=\"blue\", linewidth=2.5, linestyle=\"-\",label=\"cosine\") plt.plot(X, S, color=\"red\", linewidth=2.5, linestyle=\"-\",label=\"sine\") plt.legend(loc='upper left')#图例位置 plt.xlim(X.min()*1.1, X.max()*1.1)#边界扩大1.1倍 plt.ylim(C.min()*1.1,C.max()*1.1)#边界扩大1.1倍 plt.xticks( [-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r'$-\\pi$',r'$-\\pi / 2$',r'$0$',r'$\\pi / 2$',r'$\\pi$'])#设置x轴记号标签,用latex符号替代具体数 plt.yticks([-1, 0, +1])#设置y轴记号标签 ax = plt.gca()#脊柱 ax.spines['right'].set_color('none')#右脊柱设为无色 ax.spines['top'].set_color('none')#上脊柱设为无色 ax.xaxis.set_ticks_position('bottom')#下脊柱设定位置 ax.spines['bottom'].set_position(('data',0)) ax.yaxis.set_ticks_position('left')#左脊柱设定位置 ax.spines['left'].set_position(('data',0)) # 添加一个白色的半透明底色 for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(16) label.set_bbox(dict(facecolor='white', edgecolor='None', alpha=0.65 )) t = 2*np.pi/3 #特殊点x轴位置 plt.plot([t,t],[0,np.cos(t)], color ='blue', linewidth=2.5, linestyle=\"--\")#竖线从0到与cos(t)交点,蓝色虚线 plt.scatter([t,],[np.cos(t),], 50, color ='blue')# 画交点 plt.annotate(r'$\\sin(\\frac{2\\pi}{3})=\\frac{\\sqrt{3}}{2}$', xy=(t, np.sin(t)), xycoords='data', xytext=(+10, +30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=.2\"))#指出交点并说明公式 plt.plot([t,t],[0,np.sin(t)], color ='red', linewidth=2.5, linestyle=\"--\")#竖线从0到与sin(t)交点,红色虚线 plt.scatter([t,],[np.sin(t),], 50, color ='red')# 画交点 plt.annotate(r'$\\cos(\\frac{2\\pi}{3})=-\\frac{1}{2}$', xy=(t, np.cos(t)), xycoords='data', xytext=(-90, -50), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=.2\"))#指出交点并说明公式 plt.grid(True) plt.show() 填充颜色 fill_between方法来填充两个线条间的内容 n = 256 X = np.linspace(-np.pi,np.pi,n,endpoint=True) Y = np.sin(2*X) plt.axes([0.025,0.025,0.95,0.95]) plt.plot (X, Y+1, color='blue', alpha=1.00) plt.fill_between(X, 1, Y+1, color='blue', alpha=.25) plt.plot (X, Y-1, color='blue', alpha=1.00) plt.fill_between(X, -1, Y-1, (Y-1) > -1, color='blue', alpha=.25) plt.fill_between(X, -1, Y-1, (Y-1) 图像、子图、坐标轴和记号 到目前为止，我们都用隐式的方法来绘制图像和坐标轴。快速绘图中，这是很方便的。我们也可以显式地控制图像、子图、坐标轴。Matplotlib 中的「图像」指的是用户界面看到的整个窗口内容。在图像里面有所谓「子图」。子图的位置是由坐标网格确定的，而「坐标轴」却不受此限制，可以放在图像的任意位置。我们已经隐式地使用过图像和子图：当我们调用 plot 函数的时候，matplotlib 调用 gca() 函数以及 gcf() 函数来获取当前的坐标轴和图像；如果无法获取图像，则会调用 figure() 函数来创建一个——严格地说，是用 subplot(1,1,1) 创建一个只有一个子图的图像。 子图像 你可以用子图来将图样（plot）放在均匀的坐标网格中。用 subplot 函数的时候，你需要指明网格的行列数量，以及你希望将图样放在哪一个网格区域中。此外，gridspec 的功能更强大，你也可以选择它来实现这个功能。 plt.subplot(2,2,1) plt.xticks([]), plt.yticks([]) plt.text(0.5,0.5, 'subplot(2,2,1)',ha='center',va='center',size=20,alpha=.5) plt.subplot(2,2,2) plt.xticks([]), plt.yticks([]) plt.text(0.5,0.5, 'subplot(2,2,2)',ha='center',va='center',size=20,alpha=.5) plt.subplot(2,2,3) plt.xticks([]),plt.yticks([]) plt.text(0.5,0.5, 'subplot(2,2,3)',ha='center',va='center',size=20,alpha=.5) plt.subplot(2,2,4) plt.xticks([]), plt.yticks([]) plt.text(0.5,0.5, 'subplot(2,2,4)',ha='center',va='center',size=20,alpha=.5) # savefig('../figures/subplot-grid.png', dpi=64) plt.show() 格子grid ax = plt.axes([0.025,0.025,0.95,0.95]) ax.set_xlim(0,4) ax.set_ylim(0,3) ax.xaxis.set_major_locator(plt.MultipleLocator(1.0)) ax.xaxis.set_minor_locator(plt.MultipleLocator(0.1)) ax.yaxis.set_major_locator(plt.MultipleLocator(1.0)) ax.yaxis.set_minor_locator(plt.MultipleLocator(0.1)) ax.grid(which='major', axis='x', linewidth=0.75, linestyle='-', color='0.75') ax.grid(which='minor', axis='x', linewidth=0.25, linestyle='-', color='0.75') ax.grid(which='major', axis='y', linewidth=0.75, linestyle='-', color='0.75') ax.grid(which='minor', axis='y', linewidth=0.25, linestyle='-', color='0.75') ax.set_xticklabels([]) ax.set_yticklabels([]) plt.show() 多重网格 plt.subplot(2,2,1) plt.subplot(2,2,3) plt.subplot(2,2,4) plt.show() fig = plt.figure() fig.subplots_adjust(bottom=0.025, left=0.025, top = 0.975, right=0.975) plt.subplot(2,1,1) plt.xticks([]), plt.yticks([]) plt.subplot(2,3,4) plt.xticks([]), plt.yticks([]) plt.subplot(2,3,5) plt.xticks([]), plt.yticks([]) plt.subplot(2,3,6) plt.xticks([]), plt.yticks([]) plt.show() 坐标轴 坐标轴和子图功能类似，不过它可以放在图像的任意位置。因此，如果你希望在一副图中绘制一个小图，就可以用这个功能。 plt.axes([0.1,0.1,.8,.8]) plt.xticks([]), plt.yticks([]) plt.text(0.6,0.6, 'axes([0.1,0.1,.8,.8])',ha='center',va='center',size=20,alpha=.5) plt.axes([0.2,0.2,.3,.3]) plt.xticks([]), plt.yticks([]) plt.text(0.5,0.5, 'axes([0.2,0.2,.3,.3])',ha='center',va='center',size=16,alpha=.5) #plt.savefig(\"../figures/axes.png\",dpi=64) plt.show() plt.axes([0.1,0.1,.5,.5]) plt.xticks([]), plt.yticks([]) plt.text(0.1,0.1, 'axes([0.1,0.1,.8,.8])',ha='left',va='center',size=16,alpha=.5) plt.axes([0.2,0.2,.5,.5]) plt.xticks([]), plt.yticks([]) plt.text(0.1,0.1, 'axes([0.2,0.2,.5,.5])',ha='left',va='center',size=16,alpha=.5) plt.axes([0.3,0.3,.5,.5]) plt.xticks([]), plt.yticks([]) plt.text(0.1,0.1, 'axes([0.3,0.3,.5,.5])',ha='left',va='center',size=16,alpha=.5) plt.axes([0.4,0.4,.5,.5]) plt.xticks([]), plt.yticks([]) plt.text(0.1,0.1, 'axes([0.4,0.4,.5,.5])',ha='left',va='center',size=16,alpha=.5) # plt.savefig(\"../figures/axes-2.png\",dpi=64) plt.show() 记号 良好的记号是图像的重要组成部分。Matplotlib 里的记号系统里的各个细节都是可以由用户个性化配置的。你可以用 Tick Locators 来指定在那些位置放置记号，用 Tick Formatters 来调整记号的样式。主要和次要的记号可以以不同的方式呈现。默认情况下，每一个次要的记号都是隐藏的，也就是说，默认情况下的次要记号列表是空的——NullLocator。 下面有为不同需求设计的一些 Locators: NullLocatorNo ticks. IndexLocatorPlace a tick on every multiple of some base number of points plotted. FixedLocatorTick locations are fixed. LinearLocatorDetermine the tick locations. MultipleLocatorSet a tick on every integer that is multiple of some base. AutoLocatorSelect no more than n intervals at nice locations. LogLocatorDetermine the tick locations for log axes. 特殊图形 除了点线等基本工具,还可以直接使用设置好的类型画一些基本图形 散点图scatter n = 1024 X = np.random.normal(0,1,n) Y = np.random.normal(0,1,n) plt.scatter(X,Y) plt.show() n = 1024 X = np.random.normal(0,1,n) Y = np.random.normal(0,1,n) T = np.arctan2(Y,X) # 计算出象限 plt.axes([0.025,0.025,0.95,0.95]) plt.scatter(X,Y, s=75, c=T, alpha=.5) plt.xlim(-1.5,1.5), plt.xticks([]) plt.ylim(-1.5,1.5), plt.yticks([]) plt.show() 栅栏图bar n = 12 X = np.arange(n) Y1 = (1-X/float(n)) * np.random.uniform(0.5,1.0,n) Y2 = (1-X/float(n)) * np.random.uniform(0.5,1.0,n) plt.bar(X, +Y1, facecolor='#9999ff', edgecolor='white') plt.bar(X, -Y2, facecolor='#ff9999', edgecolor='white') for x,y in zip(X,Y1): plt.text(x+0.4, y+0.05, '%.2f' % y, ha='center', va= 'bottom') plt.ylim(-1.25,+1.25) plt.show() n = 12 X = np.arange(n) Y1 = (1-X/float(n)) * np.random.uniform(0.5,1.0,n) Y2 = (1-X/float(n)) * np.random.uniform(0.5,1.0,n) plt.axes([0.025,0.025,0.95,0.95]) plt.bar(X, +Y1, facecolor='#9999ff', edgecolor='white') plt.bar(X, -Y2, facecolor='#ff9999', edgecolor='white') for x,y in zip(X,Y1): plt.text(x+0.4, y+0.05, '%.2f' % y, ha='center', va= 'bottom') for x,y in zip(X,Y2): plt.text(x+0.4, -y-0.05, '%.2f' % y, ha='center', va= 'top') plt.xlim(-.5,n), plt.xticks([]) plt.ylim(-1.25,+1.25), plt.yticks([]) plt.show() 等高线图meshgrid def f(x,y): return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2) n = 256 x = np.linspace(-3,3,n) y = np.linspace(-3,3,n) X,Y = np.meshgrid(x,y) plt.contourf(X, Y, f(X,Y), 8, alpha=.75, cmap='jet') C = plt.contour(X, Y, f(X,Y), 8, colors='black', linewidth=.5) plt.show() def f(x,y): return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2) n = 256 x = np.linspace(-3,3,n) y = np.linspace(-3,3,n) X,Y = np.meshgrid(x,y) plt.axes([0.025,0.025,0.95,0.95]) plt.contourf(X, Y, f(X,Y), 8, alpha=.75, cmap=plt.cm.hot) C = plt.contour(X, Y, f(X,Y), 8, colors='black', linewidth=.5) plt.clabel(C, inline=1, fontsize=10) plt.xticks([]), plt.yticks([]) plt.show() 灰度图（Imshow） def f(x,y): return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2) n = 10 x = np.linspace(-3,3,4*n) y = np.linspace(-3,3,3*n) X,Y = np.meshgrid(x,y) plt.imshow(f(X,Y)) plt.show() def f(x,y): return (1-x/2+x**5+y**3)*np.exp(-x**2-y**2) n = 10 x = np.linspace(-3,3,3.5*n) y = np.linspace(-3,3,3.0*n) X,Y = np.meshgrid(x,y) Z = f(X,Y) plt.axes([0.025,0.025,0.95,0.95]) plt.imshow(Z,interpolation='nearest', cmap='bone', origin='lower') plt.colorbar(shrink=.92) plt.xticks([]), plt.yticks([]) plt.show() 饼状图 n = 20 Z = np.random.uniform(0,1,n) plt.pie(Z) plt.show() n = 20 Z = np.ones(n) Z[-1] *= 2 plt.axes([0.025,0.025,0.95,0.95]) plt.pie(Z, explode=Z*.05, colors = ['%f' % (i/float(n)) for i in range(n)]) plt.gca().set_aspect('equal') plt.xticks([]), plt.yticks([]) plt.show() 柱状图hist mu, sigma = 100, 15 x = mu + sigma * np.random.randn(10000) plt.hist(x, 50, normed=1, facecolor='g', alpha=0.75) plt.xlabel('Smarts') plt.ylabel('Probability') plt.title('Histogram of IQ') plt.text(60, .025, r'$\\mu=100,\\ \\sigma=15$') plt.axis([40, 160, 0, 0.03]) plt.grid(True) 量场图--箭头（Quiver Plots） n = 8 X,Y = np.mgrid[0:n,0:n] plt.quiver(X,Y) plt.show() n = 8 X,Y = np.mgrid[0:n,0:n] T = np.arctan2(Y-n/2.0, X-n/2.0) R = 10+np.sqrt((Y-n/2.0)**2+(X-n/2.0)**2) U,V = R*np.cos(T), R*np.sin(T) plt.axes([0.025,0.025,0.95,0.95]) plt.quiver(X,Y,U,V,R, alpha=.5) plt.quiver(X,Y,U,V, edgecolor='k', facecolor='None', linewidth=.5) plt.xlim(-1,n), plt.xticks([]) plt.ylim(-1,n), plt.yticks([]) plt.show() 极轴图 plt.axes([0,0,1,1]) N = 20 theta = np.arange(0.0, 2*np.pi, 2*np.pi/N) radii = 10*np.random.rand(N) width = np.pi/4*np.random.rand(N) bars = plt.bar(theta, radii, width=width, bottom=0.0) for r,bar in zip(radii, bars): bar.set_facecolor( plt.cm.jet(r/10.)) bar.set_alpha(0.5) plt.show() ax = plt.axes([0.025,0.025,0.95,0.95], polar=True) N = 20 theta = np.arange(0.0, 2*np.pi, 2*np.pi/N) radii = 10*np.random.rand(N) width = np.pi/4*np.random.rand(N) bars = plt.bar(theta, radii, width=width, bottom=0.0) for r,bar in zip(radii, bars): bar.set_facecolor( plt.cm.jet(r/10.)) bar.set_alpha(0.5) ax.set_xticklabels([]) ax.set_yticklabels([]) plt.show() 3D 图 from mpl_toolkits.mplot3d import Axes3D fig = plt.figure() ax = Axes3D(fig) X = np.arange(-4, 4, 0.25) Y = np.arange(-4, 4, 0.25) X, Y = np.meshgrid(X, Y) R = np.sqrt(X**2 + Y**2) Z = np.sin(R) ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap='hot') plt.show() fig = plt.figure() ax = Axes3D(fig) X = np.arange(-4, 4, 0.25) Y = np.arange(-4, 4, 0.25) X, Y = np.meshgrid(X, Y) R = np.sqrt(X**2 + Y**2) Z = np.sin(R) ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.cm.hot) ax.contourf(X, Y, Z, zdir='z', offset=-2, cmap=plt.cm.hot) ax.set_zlim(-2,2) plt.show() 手稿 eqs = [] eqs.append((r\"$W^{3\\beta}_{\\delta_1 \\rho_1 \\sigma_2} = U^{3\\beta}_{\\delta_1 \\rho_1} + \\frac{1}{8 \\pi 2} \\int^{\\alpha_2}_{\\alpha_2} d \\alpha^\\prime_2 \\left[\\frac{ U^{2\\beta}_{\\delta_1 \\rho_1} - \\alpha^\\prime_2U^{1\\beta}_{\\rho_1 \\sigma_2} }{U^{0\\beta}_{\\rho_1 \\sigma_2}}\\right]$\")) eqs.append((r\"$\\frac{d\\rho}{d t} + \\rho \\vec{v}\\cdot\\nabla\\vec{v} = -\\nabla p + \\mu\\nabla^2 \\vec{v} + \\rho \\vec{g}$\")) eqs.append((r\"$\\int_{-\\infty}^\\infty e^{-x^2}dx=\\sqrt{\\pi}$\")) eqs.append((r\"$E = mc^2 = \\sqrt{{m_0}^2c^4 + p^2c^2}$\")) eqs.append((r\"$F_G = G\\frac{m_1m_2}{r^2}$\")) plt.axes([0.025,0.025,0.95,0.95]) for i in range(24): index = np.random.randint(0,len(eqs)) eq = eqs[index] size = np.random.uniform(12,32) x,y = np.random.uniform(0,1,2) alpha = np.random.uniform(0.25,.75) plt.text(x, y, eq, ha='center', va='center', color=\"#11557c\", alpha=alpha, transform=plt.gca().transAxes, fontsize=size, clip_on=True) plt.xticks([]), plt.yticks([]) # savefig('../figures/text_ex.png',dpi=48) plt.show() 箱形图 箱形图可以用来集中化的体现数据的特点 np.random.seed(937) data = np.random.lognormal(size=(37, 4), mean=1.5, sigma=1.75) labels = list('ABCD') fs = 10 # fontsize # demonstrate how to toggle the display of different elements: fig, axes = plt.subplots(nrows=2, ncols=3, figsize=(6, 6)) axes[0, 0].boxplot(data, labels=labels) axes[0, 0].set_title('Default', fontsize=fs) axes[0, 1].boxplot(data, labels=labels, showmeans=True) axes[0, 1].set_title('showmeans=True', fontsize=fs) axes[0, 2].boxplot(data, labels=labels, showmeans=True, meanline=True) axes[0, 2].set_title('showmeans=True,\\nmeanline=True', fontsize=fs) axes[1, 0].boxplot(data, labels=labels, showbox=False, showcaps=False) axes[1, 0].set_title('Tufte Style \\n(showbox=False,\\nshowcaps=False)', fontsize=fs) axes[1, 1].boxplot(data, labels=labels, notch=True, bootstrap=10000) axes[1, 1].set_title('notch=True,\\nbootstrap=10000', fontsize=fs) axes[1, 2].boxplot(data, labels=labels, showfliers=False) axes[1, 2].set_title('showfliers=False', fontsize=fs) for ax in axes.flatten(): ax.set_yscale('log') ax.set_yticklabels([]) fig.subplots_adjust(hspace=0.4) plt.show() # demonstrate how to customize the display different elements: boxprops = dict(linestyle='--', linewidth=3, color='darkgoldenrod') flierprops = dict(marker='o', markerfacecolor='green', markersize=12, linestyle='none') medianprops = dict(linestyle='-.', linewidth=2.5, color='firebrick') meanpointprops = dict(marker='D', markeredgecolor='black', markerfacecolor='firebrick') meanlineprops = dict(linestyle='--', linewidth=2.5, color='purple') fig, axes = plt.subplots(nrows=2, ncols=3, figsize=(6, 6)) axes[0, 0].boxplot(data, boxprops=boxprops) axes[0, 0].set_title('Custom boxprops', fontsize=fs) axes[0, 1].boxplot(data, flierprops=flierprops, medianprops=medianprops) axes[0, 1].set_title('Custom medianprops\\nand flierprops', fontsize=fs) axes[0, 2].boxplot(data, whis='range') axes[0, 2].set_title('whis=\"range\"', fontsize=fs) axes[1, 0].boxplot(data, meanprops=meanpointprops, meanline=False, showmeans=True) axes[1, 0].set_title('Custom mean\\nas point', fontsize=fs) axes[1, 1].boxplot(data, meanprops=meanlineprops, meanline=True, showmeans=True) axes[1, 1].set_title('Custom mean\\nas line', fontsize=fs) axes[1, 2].boxplot(data, whis=[15, 85]) axes[1, 2].set_title('whis=[15, 85]\\n#percentiles', fontsize=fs) for ax in axes.flatten(): ax.set_yscale('log') ax.set_yticklabels([]) fig.suptitle(\"I never said they'd be pretty\") fig.subplots_adjust(hspace=0.4) plt.show() 更多的图形可以在http://matplotlib.org/api/pyplot_summary.html中查看 Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-18 17:32:54 "},"matplotlib/Sankey_diagram/Sankey_diagram.html":{"url":"matplotlib/Sankey_diagram/Sankey_diagram.html","title":"桑基图","keywords":"","body":"桑基图 桑基图（Sankey diagram），即桑基能量分流图，也叫桑基能量平衡图。一种特定类型的流程图，图中延伸的分支的宽度对应数据流量的大小, 通常应用于能源、材料成分、金融等数据的可视化分析。 因1898年Matthew Henry Phineas Riall Sankey绘制的\"蒸汽机的能源效率图\"而闻名，此后便以其名字命名为“桑基图”。 桑基图最明显的特征就是，始末端的分支宽度总和相等，即所有主支宽度的总和应与所有分出去的分支宽度的总和相等，保持能量的平衡。 import numpy as np import matplotlib.pyplot as plt from matplotlib.sankey import Sankey %matplotlib inline matplotlib.sankey.Sankey(ax=None, scale=1.0, unit='', format='%G', gap=0.25, radius=0.1, shoulder=0.03, offset=0.15, head_angle=100, margin=0.4, tolerance=1e-06, **kwargs)是matplotlib构建桑基图的工具 他有两个方法来构造图形 .add(patchlabel='', flows=None, orientations=None, labels='', trunklength=1.0, pathlengths=0.25, prior=None, connect=(0, 0), rotation=0, **kwargs) flows就是流入的百分比了负数表示为流出 labels是每个流的标签 orientations 的取值范围为[-1,0,1]有效值为1（从顶部到顶部），0（从左到右）或-1（从底部到底部）.如果orientation = 0，输入将从左边突入，输出将向右边突破。 add()返回的还是一个Sankey对象,因此链式操作一直add() .finish()构造结束 S=Sankey() S.add(flows=[0.25, 0.15, 0.60, -0.20, -0.15, -0.05, -0.50, -0.10], labels=['', '', '', 'First', 'Second', 'Third', 'Fourth', 'Fifth'], orientations=[-1, 1, 0, 1, 1, 1, 0, -1]).finish() S 我们也可以直接在构造函数里定义流 Sankey(flows=[0.25, 0.15, 0.60, -0.20, -0.15, -0.05, -0.50, -0.10], labels=['', '', '', 'First', 'Second', 'Third', 'Fourth', 'Fifth'], orientations=[-1, 1, 0, 1, 1, 1, 0, -1]).finish() plt.title(\"The default settings produce a diagram like this.\") 我们可以在finish()之后通过一些针对其中元素的操作做特殊化处理 fig = plt.figure() ax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[], title=\"Flow Diagram of a Widget\") sankey = Sankey(ax=ax, scale=0.01, offset=0.2, head_angle=180, format='%.0f', unit='%')# 单位unit定义 sankey.add(flows=[25, 0, 60, -10, -20, -5, -15, -10, -40], labels=['', '', '', 'First', 'Second', 'Third', 'Fourth', 'Fifth', 'Hurray!'], orientations=[-1, 1, 0, 1, 1, 1, -1, -1, 0], pathlengths=[0.25, 0.25, 0.25, 0.25, 0.25, 0.6, 0.25, 0.25, 0.25], patchlabel=\"Widget\\nA\", alpha=0.2, lw=2.0) # Arguments to matplotlib.patches.PathPatch() diagrams = sankey.finish() diagrams[0].patch.set_facecolor('#37c959') diagrams[0].texts[-1].set_color('r') diagrams[0].text.set_fontweight('bold') 如果有两张图用来表现两个系统的关系,可以像下面这么做 fig = plt.figure() ax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[], title=\"Two Systems\") flows = [0.25, 0.15, 0.60, -0.10, -0.05, -0.25, -0.15, -0.10, -0.35] sankey = Sankey(ax=ax, unit=None) sankey.add(flows=flows, label='one', orientations=[-1, 1, 0, 1, 1, 1, -1, -1, 0]) sankey.add(flows=[-0.25, 0.15, 0.1], fc='#37c959', label='two', orientations=[-1, -1, -1], prior=0, connect=(0, 0)) diagrams = sankey.finish() diagrams[-1].patch.set_hatch('/') plt.legend(loc='best') Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-18 17:33:44 "},"matplotlib/triangular_grids/triangular_grids.html":{"url":"matplotlib/triangular_grids/triangular_grids.html","title":"非结构图形","keywords":"","body":"非结构网络 非结构网格是没有规则拓扑关系的网格，它通常由多边形三角形组成。 网格中的每个每个元素都可以是二维的多边形或者三维多面体，其中最常见的是二维的三角形以及三维的四面体。 在每个元素之间没有隐含的连通性。 由于结构网格面对复杂几何外形时生成困难，以及耗费大量人工，自动化程度不高等缺点，非结构网格逐渐发展起来.使用它的技术主要有流体分析,空气动力学,有限元分析等细分领域. matplotlib中有针对它的作图工具matplotlib.tri模块 核心类class matplotlib.tri.Triangulation(x, y, triangles=None, mask=None) 由n个point点和n个三角形组成的非结构化三角形网格。三角形可以由用户指定或使用Delaunay三角测量自动生成。 x,y对应网格点的坐标 triangles 对于每个三角形，组成三角形的三个点的索引以逆时针方式排序。如果未指定，则计算Delaunay三角剖分。 mask 指定哪些三角形的屏蔽数组 它的方法有: calculate_plane_coefficients(z) 从点（x，y）坐标和指定的z形阵列（n points）计算所有未屏蔽三角形的平面方程系数。返回的数组具有形状（n points，3）并且允许使用 z = array [tri，0] x array [tri，1] y array [tri，2] edges 返回包含非屏蔽三角形的所有边的整型数组形状（nedges，2）。每个边是起点索引和终点索引。每个边（开始，结束和结束，开始）只出现一次。 get_masked_triangles() 返回未屏蔽的三角形数组。 get_trifinder() 返回此三角剖分的默认matplotlib.tri.TriFinder,如果需要,创建它.这允许轻松共享相同的TriFinder对象。 neighbors 邻点 set_mask(mask) 设置或清除屏蔽数组. 寻找是三角形算法 matplotlib.tri.TriFinder(triangulation) TriFinder类使用来自M.de Berg，M.van Kreveld，M.Overmars和O. Schwarzkopf的书“Computational Geometry，Algorithms and Applications”，第二版中的梯形映射算法来实现。三角测量必须有效，即它不能具有重复的点，由共线点形成的三角形或重叠的三角形。该算法对于由共线点形成的三角形具有一些公差，但是这不应被依赖。 这个类的实例可以被调用 trifinder(x,y),调用后会 返回包含指定x，y点所在的三角形的索引的数组，或者对于不在三角形内的点返回-1。 x，y是相同形状和任意数量维度的类阵列x和y坐标。 返回具有相同形状和x和y的整数数组。 三角形网格线性插值 matplotlib.tri.LinearTriInterpolator(triangulation, z, trifinder=None) LinearTriInterpolator对三角形网格执行线性插值。每个三角形由平面表示，使得点（x，y）处的内插值位于包含（x，y）的三角形的平面上。因此，内插值在三角形上是连续的，但是它们的一阶导数在三角形之间的边缘处是不连续的。 他的实例有方法gradient(x, y),可以返回在指定的x，y点包含插值导数的2个包含屏蔽数组的列表。 而实例被调用会返回在指定的x，y点包含插值的屏蔽数组。 三角形网格执行三次插值 matplotlib.tri.CubicTriInterpolator(triangulation, z, kind='min_E', trifinder=None, dz=None) CubicTriInterpolator对三角形网格执行三次插值。在一维, 一段上 做三次插值,函数由函数的值和其两端的导数定义。这在三角形内的2-d中几乎相同，除了函数的值及其2导数必须在每个三角形节点处定义。CubicTriInterpolator获取每个节点（由用户提供）的函数值，并在内部计算导数的值，从而实现平滑插值。 （作为一个特殊功能，用户还可以在每个节点强加导数的值，但这不应该是常见的用法。） kind 选择平滑算法，以便计算内插导数（默认为“min_E”）：如果'min_E'：（默认）计算每个节点处的导数以最小化弯曲能量。如果'geom'：每个节点的导数被计算为相关三角形法线的加权平均值。用于速度优化（大网格）。如果'user'：用户提供参数dz，因此不需要计算。 trifinder 如果未指定，Triangulation的默认TriFinder将通过调用matplotlib.tri.Triangulation.get_trifinder（）来使用。 dz 仅在kind ='user'时使用。在这种情况下，dz必须提供为（dzdx，dzdy），其中dzdx，dzdy是与z相同形状的数组，并且是三角点处的内插一阶导数。 内插基于三角网格的Clough-Tocher细分方案（为了使其更清楚，网格的每个三角形将被划分为3个子三角形，并且在每个子三角形上，内插函数是2的三次多项式坐标）。这种技术源自FEM（有限元方法）分析;使用的元件是还原的Hsieh-Clough-Tocher（HCT）元件。其形状函数在[R1]中描述。组合函数保证是C1平滑的，即它是连续的，并且其一阶导数也是连续的（这在三角形内容中是容易显示的，但当穿过边缘时也是如此）。 在默认情况下（种类='min_E'），内插器使由HCT元素形状函数生成的函数空间上的曲率能量最小化 - 利用施加的值，但在每个节点处的任意导数。最小化的函数是所谓的总曲率的积分（基于来自[R2] -PCG稀疏求解器的算法的实现）： $ E(z) = {\\frac 1 2 } \\int_\\Omega ((\\frac {\\partial^2 z} {\\partial x^2} )^2 + (\\frac {\\partial^2 z} {\\partial y^2} )^2 +2(\\frac {\\partial^2 z} {\\partial y \\partial x} )^2)dxdy $ 如果用户选择case type ='geom'，则使用简单的几何近似（三角形法线向量的加权平均），这可以在非常大的网格上提高速度。 例子: from matplotlib.tri import Triangulation, UniformTriRefiner,\\ CubicTriInterpolator import matplotlib.pyplot as plt import matplotlib.cm as cm import numpy as np import math # 计算偶极子的电位 def dipole_potential(x, y): \"\"\" The electric dipole potential V \"\"\" r_sq = x**2 + y**2 theta = np.arctan2(y, x) z = np.cos(theta)/r_sq return (np.max(z) - z) / (np.max(z) - np.min(z)) # 创建三角网格 #----------------------------------------------------------------------------- # 首先创建点的x和y坐标 n_angles = 30 n_radii = 10 min_radius = 0.2 radii = np.linspace(min_radius, 0.95, n_radii) angles = np.linspace(0, 2*math.pi, n_angles, endpoint=False) angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1) angles[:, 1::2] += math.pi/n_angles x = (radii*np.cos(angles)).flatten() y = (radii*np.sin(angles)).flatten() V = dipole_potential(x, y) V[:5] array([ 0. , 0.25222984, 0.35123967, 0.40177562, 0.4296875 ]) triang = Triangulation(x, y) # 屏蔽掉不需要的值 xmid = x[triang.triangles].mean(axis=1) ymid = y[triang.triangles].mean(axis=1) mask = np.where(xmid*xmid + ymid*ymid # 精细化数据 - 内插电位V refiner = UniformTriRefiner(triang) tri_refi, z_test_refi = refiner.refine_field(V, subdiv=3) # 计算电场（Ex，Ey）作为电位梯度 tci = CubicTriInterpolator(triang, -V) # 这里,gradient()需要 网格节点，但可以在其他任何地方 (Ex, Ey) = tci.gradient(triang.x, triang.y) E_norm = np.sqrt(Ex**2 + Ey**2) #作图 plt.figure() plt.gca().set_aspect('equal') plt.triplot(triang, color='0.8') levels = np.arange(0., 1., 0.01) cmap = cm.get_cmap(name='hot', lut=None) # 三角等高线 plt.tricontour(tri_refi, z_test_refi, levels=levels, cmap=cmap, linewidths=[2.0, 1.0, 1.0, 1.0]) # 用quiver绘制电矢量场的方向 plt.quiver(triang.x, triang.y, Ex/E_norm, Ey/E_norm, units='xy', scale=10., zorder=3, color='blue', width=0.007, headwidth=3., headlength=4.) plt.title('Gradient plot: an electrical dipole') plt.show() 通过递归细分的均匀网格细化 matplotlib.tri.UniformTriRefiner(triangulation)类 通过递归细分的均匀网格细化。 它有方法 refine_field(z, triinterpolator=None, subdiv=3) 用来优化在封装三角定义上定义的字段 triinterpolator插值器用于场插值。如果未指定，将使用CubicTriInterpolator。 subdiv细分的递归级别。默认为3.每个三角形将被划分为4个**子细分三角形。 refine_triangulation(return_tri_index=False, subdiv=3) 计算封装三角测量的均匀精细三角测量refi_triangulation。此函数通过将每个父三角形递归地（递归细分的水平）分割成在边中间节点上构建的4个子子三角形，来细化封装的三角形。最后，每个三角形因此被划分为4 **个子三角形。 subdiv的默认值为3，从而为初始三角形的每个三角形产生64个精细子三角形。 return_tri_index布尔值，指示是否将返回指示每个点的父三角形索引的索引表。默认值False。 例子:在粗糙的三角形网格（例如，由相对稀疏的测试数据构建的三角测量）上绘制高质量等高线： # 在用户定义的三角网格上演示高分辨率三轴定位用matplotlib.tri.UniformTriRefiner import matplotlib.tri as tri # 要分析测试的function def function_z(x, y): \"\"\" A function of 2 variables \"\"\" r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2) theta1 = np.arctan2(0.5 - x, 0.5 - y) r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2) theta2 = np.arctan2(-x - 0.2, -y - 0.2) z = -(2*(np.exp((r1/10)**2) - 1)*30. * np.cos(7.*theta1) + (np.exp((r2/10)**2) - 1)*30. * np.cos(11.*theta2) + 0.7*(x**2 + y**2)) return (np.max(z) - z)/(np.max(z) - np.min(z)) # 构建三角网络中的点 n_angles = 20 n_radii = 10 min_radius = 0.15 radii = np.linspace(min_radius, 0.95, n_radii) angles = np.linspace(0, 2*math.pi, n_angles, endpoint=False) angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1) angles[:, 1::2] += math.pi/n_angles x = (radii*np.cos(angles)).flatten() y = (radii*np.sin(angles)).flatten() z = function_z(x, y) #开始构建三角网络 triang = tri.Triangulation(x, y) # 屏蔽不要的店 xmid = x[triang.triangles].mean(axis=1) ymid = y[triang.triangles].mean(axis=1) mask = np.where(xmid*xmid + ymid*ymid # 精细化数据 refiner = tri.UniformTriRefiner(triang) tri_refi, z_test_refi = refiner.refine_field(z, subdiv=3) plt.figure() plt.gca().set_aspect('equal') plt.triplot(triang, lw=0.5, color='white') levels = np.arange(0., 1., 0.025) cmap = cm.get_cmap(name='terrain', lut=None) plt.tricontourf(tri_refi, z_test_refi, levels=levels, cmap=cmap) plt.tricontour(tri_refi, z_test_refi, levels=levels, colors=['0.25', '0.5', '0.5', '0.5', '0.5'], linewidths=[1.0, 0.5, 0.5, 0.5, 0.5]) plt.title(\"High-resolution tricontouring\") plt.show() 三角网格分析和改进的基本工具 matplotlib.tri.TriAnalyzer(triangulation) 定义三角网格分析和改进的基本工具。TriAnalizer封装了一个Triangulation对象，并提供了用于网格分析和网格改进的基本工具。 它有三个方法 circle_ratios(rescale=True) 返回三角形的三角形平坦度的度量。 圆周半径与外接圆半径的比率是广泛使用的三角形平坦度的指标。对于等边三角形，它总是 get_flat_tri_mask(min_circle_ratio=0.01, rescale=True) 消除三角测量中过分平坦的边界三角形。返回一个屏蔽数组new_mask(布尔值)，它允许从边界定位的平面三角形（根据他们的circle_ratios（））清除封装的三角剖分。这个屏蔽数组意味着随后应用于使用matplotlib.tri.Triangulation.set_mask（）的三角测量。 new_mask是初始三角形掩模的扩展，在初始掩模的三角形将保持掩蔽的意义上。new_mask数组是递归计算的;在每个步骤，只有当它们与当前网格边界共享一侧时，才移除平面三角形。因此，在三角域中将不产生新的空穴。 + min_circle_ratio 如果内圆/外圆半径比r/R 这个函数的基本原理是Delaunay三角形(一个非结构化的点集合,有时在边界处包含几乎平坦的三角形)，导致绘图中的伪像（特别是对于高分辨率轮廓化）。用计算的new_mask掩蔽，封装的三角剖分将不包含具有低于min_circle_ratio的圆比率的更多未掩蔽的边界三角形，从而改进后续绘图或插值的网格质量。 例子:随机集合的高分辨率定向 本演示的初始数据点和三角网格为： 在[-1,1]×[-1,1]正方形内部实例化一组随机点 然后计算这些点的Delaunay三角剖分，其中a 随机子集的三角形被用户掩盖（基于 init_mask_frac 参数）。 这将模拟无效的数据。 提出的通用程序获得高分辨率轮廓的这种 数据集如下： 使用matplotlib.tri.TriAnalyzer计算扩展屏蔽,从边框中排除形状不好（平）的三角形三角测量。 将屏蔽应用于三角剖分（使用set_mask）。 使用a来细化和内插数据matplotlib.tri.UniformTriRefiner。 用tricontour绘制精制数据。 from matplotlib.tri import Triangulation, TriAnalyzer, UniformTriRefiner #----------------------------------------------------------------------------- # 用于测试的函数 #----------------------------------------------------------------------------- def experiment_res(x, y): \"\"\" 表实验结果的分析函数\"\"\" x = 2.*x r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2) theta1 = np.arctan2(0.5 - x, 0.5 - y) r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2) theta2 = np.arctan2(-x - 0.2, -y - 0.2) z = (4*(np.exp((r1/10)**2) - 1)*30. * np.cos(3*theta1) + (np.exp((r2/10)**2) - 1)*30. * np.cos(5*theta2) + 2*(x**2 + y**2)) return (np.max(z) - z)/(np.max(z) - np.min(z)) #----------------------------------------------------------------------------- # 生成初始数据测试点和演示的三角测量 #----------------------------------------------------------------------------- n_test = 200 # 测试数据点数，对于subdiv = 3从3到5000进行测试 subdiv = 3 # 平滑图的初始网格的递归细分数。 #值> 3可能导致精细网格的三角形数量非常多：new triangles numbering =（4 ** subdiv）* ntri init_mask_frac = 0.0 min_circle_ratio = .01 # 随机点 random_gen = np.random.mtrand.RandomState(seed=127260) x_test = random_gen.uniform(-1., 1., size=n_test) y_test = random_gen.uniform(-1., 1., size=n_test) z_test = experiment_res(x_test, y_test) # 使用Delaunay三角网格划分 tri = Triangulation(x_test, y_test) ntri = tri.triangles.shape[0] # 剔除一些要屏蔽的点 mask_init = np.zeros(ntri, dtype=np.bool) masked_tri = random_gen.randint(0, ntri, int(ntri*init_mask_frac)) mask_init[masked_tri] = True tri.set_mask(mask_init) #----------------------------------------------------------------------------- # 在高分辨率绘图之前改进三角测量：删除平面三角形 #----------------------------------------------------------------------------- # 掩蔽在三角形网格的边界处的不良形状的三角形 mask = TriAnalyzer(tri).get_flat_tri_mask(min_circle_ratio) tri.set_mask(mask) # 精细化数据 refiner = UniformTriRefiner(tri) tri_refi, z_test_refi = refiner.refine_field(z_test, subdiv=subdiv) # 用于与分析进行比较 z_expected = experiment_res(tri_refi.x, tri_refi.y) flat_tri = Triangulation(x_test, y_test) flat_tri.set_mask(~mask) #开始画图 plot_tri = True # plot of base triangulation plot_masked_tri = True # plot of excessively flat excluded triangles plot_refi_tri = False # plot of refined triangulation plot_expected = False # plot of analytical function values for comparison # Graphical options for tricontouring levels = np.arange(0., 1., 0.025) cmap = cm.get_cmap(name='Blues', lut=None) plt.figure() plt.gca().set_aspect('equal') plt.title(\"Filtering a Delaunay mesh\\n\" + \"(application to high-resolution tricontouring)\") # 1) 精确（计算）数据轮廓的图： plt.tricontour(tri_refi, z_test_refi, levels=levels, cmap=cmap, linewidths=[2.0, 0.5, 1.0, 0.5]) # 2) 预期（分析）数据轮廓（虚线）的图： if plot_expected: plt.tricontour(tri_refi, z_expected, levels=levels, cmap=cmap, linestyles='--') # 3) 进行内插的细网格的图： if plot_refi_tri: plt.triplot(tri_refi, color='0.97') # 4) 初始“粗糙”网格的图： if plot_tri: plt.triplot(tri, color='0.7') # 4) 从原生的Delaunay三角形而来的未经验证的三角形的图： if plot_masked_tri: plt.triplot(flat_tri, color='red') plt.show() scale_factors 将三角划分为以平方为单位。 Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-18 17:35:10 "},"matplotlib/load_image/load_image.html":{"url":"matplotlib/load_image/load_image.html","title":"图片加载","keywords":"","body":"图片加载 matplotlib.image模块提供了读取图片和进行简单处理的能力,他的底层是pillow import numpy as np import matplotlib.pyplot as plt import matplotlib.image as mpimg img=mpimg.imread('./source/cat.jpg') 通过imread()方法读取的图片会被转换成像素矩阵(numpy的narray对象),其shape与图像分辨率有关,比如: 上图是342x220的图片,那么 img.shape (220, 342, 3) 其中的3为每个像素表现为一个RGB的三位数组 img array([[[254, 254, 254], [254, 254, 254], [254, 254, 254], ..., [255, 255, 255], [255, 255, 255], [255, 255, 255]], [[254, 254, 254], [254, 254, 254], [254, 254, 254], ..., [255, 255, 255], [255, 255, 255], [255, 255, 255]], [[254, 254, 254], [254, 254, 254], [255, 255, 255], ..., [255, 255, 255], [255, 255, 255], [255, 255, 255]], ..., [[255, 255, 255], [255, 255, 255], [255, 255, 255], ..., [255, 255, 255], [255, 255, 255], [255, 255, 255]], [[255, 255, 255], [255, 255, 255], [255, 255, 255], ..., [255, 255, 255], [255, 255, 255], [255, 255, 255]], [[255, 255, 255], [255, 255, 255], [255, 255, 255], ..., [255, 255, 255], [255, 255, 255], [255, 255, 255]]], dtype=uint8) 我们可以通过plt.imshow(img)将这个数组初始化为一个plot对象 imgplot = plt.imshow(img) plt.show() 当然了只要是相同格式的数组都可以通过这个方式初始化为一个plot对象 将假彩色方案应用于图像绘图 伪彩色可以是一个有用的工具，用于增强对比度和更容易地可视化数据。这在使用投影仪对数据进行演示时尤其有用(它们的对比度通常很差)。假彩色仅与单通道，灰度，光度图像相关。我们目前有一个RGB图像。由于R，G和B都是相似的（见上面或在你的数据中的自己），我们可以只选择一个通道的数据： lum_img_r = img[:,:,0] lum_img_r array([[254, 254, 254, ..., 255, 255, 255], [254, 254, 254, ..., 255, 255, 255], [254, 254, 255, ..., 255, 255, 255], ..., [255, 255, 255, ..., 255, 255, 255], [255, 255, 255, ..., 255, 255, 255], [255, 255, 255, ..., 255, 255, 255]], dtype=uint8) lum_img_r.shape (220, 342) plt.imshow(lum_img_r) plt.show() lum_img_g = img[:,:,1] plt.imshow(lum_img_g) plt.show() lum_img_g = img[:,:,2] plt.imshow(lum_img_g) plt.show() 现在我们以使用R为通道的图片,使用亮度（2D，无颜色）图像，应用默认色彩映射（也称为查找表，LUT）。默认值称为jet。有很多其他的也可以选择。 plt.imshow(lum_img_r, cmap=\"hot\") plt.show() 也还可以使用set_cmap()方法更改现有绘图对象上的颜色 imgplot = plt.imshow(lum_img_r) imgplot.set_cmap('spectral') plt.show() /Users/huangsizhe/LIB/CONDA/anaconda/lib/python3.6/site-packages/matplotlib/cbook.py:136: MatplotlibDeprecationWarning: The spectral and spectral_r colormap was deprecated in version 2.0. Use nipy_spectral and nipy_spectral_r instead. warnings.warn(message, mplDeprecation, stacklevel=1) 色标参考 它有助于了解颜色代表什么值。我们可以通过添加颜色条来做到这一点。 imgplot = plt.imshow(lum_img_r) plt.colorbar() plt.show() 检查特定数据范围 有时，您想要增强图像的对比度，或者在特定区域中扩大对比度，同时牺牲不会变化很大的颜色的细节，或者无关紧要。找到感兴趣区域的好工具是直方图。要创建我们的图像数据的直方图，我们使用hist（）函数。 plt.hist(lum_img_r.ravel(), bins=256,fc='k', ec='k') plt.show() 下图就显示出了各个色值的分布状态,看打出来25x为值的是大多数中的大多数 通常，图像的“有趣”部分在峰值附近，您可以通过剪切峰值上方和/或下方的区域获得额外的对比度。在我们的直方图中，看起来在高端没有太多有用的信息（图像中不是很多白色的东西）。让我们调整上限，以便我们有效地“放大”直方图的一部分。我们通过将clim参数传递给imshow来实现。你也可以通过调用图像绘图对象的set_clim（）方法来做到这一点，但是要确保你在使用IPython Notebook时在plot命令的同一个单元格中这样做 - 它不会改变以前单元格的绘图。 imgplot = plt.imshow(lum_img_r, clim=(0, 200)) plt.show() 阵列插值方案 插值根据不同的数学方案计算像素的“应该”的颜色或值。这种情况发生的一个常见的地方是当你调整图像的大小。像素的数量变化，但你想要相同的信息。由于像素是离散的，因此缺少空间。插值是如何填补这个空间。这就是为什么你的图像有时拉伸会出来看起来像素化。当原始图像和扩展图像之间的差异较大时，效果更加明显。比如windows显示像素如果过分低于你的屏幕像素,那么你拉伸到屏幕那么大,看起来就都是马赛克,就是这个效果. 而插值算法就是拉伸时如何模拟的去显示出缺失信息的技术 from PIL import Image img = Image.open('./source/cat.jpg') img.thumbnail((64, 64), Image.ANTIALIAS) # 将图片压缩到64x64像素 img.height,img.width#41是因为图片比例 (41, 64) imgplot = plt.imshow(img) plt.show() 内置的插值算法有 'nearest', 最近值,也就是马赛克块 'bilinear', 双线性插值 'bicubic',双三次插值 'spline16'/'spline36', 样条插值 'hanning'/'hamming'/'gaussian'/'kaiser'/'bessel'/'sinc' 窗插值算法 'hermite',埃尔米特插值 'quadric',二次曲面插值 'catrom',[Catmull-Rom插值算法]https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline 'mitchell' 'lanczos'Lanczos算法 imgplot = plt.imshow(img, interpolation=\"nearest\") plt.show() 使用双三次插值(bicubic)模糊处理 imgplot = plt.imshow(img, interpolation=\"bicubic\") plt.show() 图片修改分辨率 img模块还提供了一个缩略图的工具 matplotlib.image.thumbnail(infile, thumbfile, scale=0.1, interpolation='bilinear', preview=False) 它可以直接修改文件并保存为另一文件,只是类型限制在png,svg和pdf三种 mpimg.thumbnail(\"./source/cat.jpg\", \"./source/cat_min.png\", scale=0.15, interpolation='bicubic') Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-18 17:10:30 "},"matplotlib/save_img/save_img.html":{"url":"matplotlib/save_img/save_img.html","title":"图片保存","keywords":"","body":"保存图片 保存图片可以使用matplotlib.pyplot.savefig来实现 from matplotlib import pyplot as plt import numpy as np %matplotlib inline fig = plt.figure(figsize=(40,40)) x=np.linspace(-4,4,30) y=np.sin(x) plt.plot(x,y,'--*b') fig.savefig(\"./source/sin_ex.png\", dpi=15) Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-18 17:34:22 "},"matplotlib/animation/animation.html":{"url":"matplotlib/animation/animation.html","title":"动画","keywords":"","body":"动画 动画说白了就是隔段时间刷新一下画面,matplotlib.animation提供了构建动画的工具主要是这几个方法: 通过函数构建 通过作品构建 通过继承matplotlib.animation.TimedAnimation类制作动画 动画需要后渲染后端,一般使用ffmpeg,安装方法可以看]这里 无论哪种方式构建的动画都可以通过.save方法保存为希望的格式,也可以用.to_html5_video方法输出一份html5可以读取的文件. from __future__ import print_function from imp import reload import matplotlib reload(matplotlib) matplotlib.use('nbagg') import matplotlib.backends.backend_nbagg reload(matplotlib.backends.backend_nbagg) import matplotlib.backends.backend_webagg_core reload(matplotlib.backends.backend_webagg_core) import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation plt.interactive(False) 通过函数构建动画 matplotlib.animation.FuncAnimation(fig, func, frames=None, init_func=None, fargs=None, save_count=None, **kwargs) FuncAnimation类是最常用的构建函数. 他的构造函数有这样一些参数 fig 一个figure对象,图像都是基于这个对象相当于一个画板 func(frame)->tuple(axes.plot) 一个构建动画函数,参数是frames传入的每一帧,而返回的是一个由参数构建的plot对象构成的tuple frames 一个可迭代对象,可以是生成器,可以是一个序列,也可以是数字,数字相当于传入一个xrange(n) init_func(frame)->tuple(axes.plot) 初始化函数,第0帧时候调用它构建图形 如果blit = True，func和init_func必须返回一个可迭代的作品对象来重绘 kwargs包括repeat，repeat_delay和interval： interval每隔interval毫秒绘制一个新帧。 repeat控制动画是否应在帧序列完成时重复。 repeat_delay可选地在重复动画之前添加以毫秒为单位的延迟。 from IPython.display import HTML %matplotlib inline plt.style.use(\"animation_support\") 使用数字定义帧 fig, ax = plt.subplots() x = np.arange(0, 2*np.pi, 0.01) line, = ax.plot(x, np.sin(x)) def animate(i): line.set_ydata(np.sin(x + i/10.0)) # update the data return line, # Init only required for blitting to give a clean slate. def init(): line.set_ydata(np.ma.array(x, mask=True)) return line, ani = animation.FuncAnimation(fig, animate, 200, init_func=init, interval=25, blit=True) ani Your browser does not support the video tag. 使用生成器定义帧 # 使用生成器构建每一帧的传入数据 def data_gen(t=0): cnt = 0 while cnt = xmax: ax.set_xlim(xmin, 2*xmax) ax.figure.canvas.draw() line.set_data(xdata, ydata) return line, ani = animation.FuncAnimation(fig, run, data_gen, blit=False, interval=10, repeat=False, init_func=init) ani Your browser does not support the video tag. 通过作品组合构建动画 matplotlib.animation.ArtistAnimation(fig, artists, *args, **kwargs) 这种方式和上面类似,只是先画好每一幅图,之后按顺序和指定的帧率制作动画 fig2 = plt.figure() x = np.arange(-9, 10) y = np.arange(-9, 10).reshape(-1, 1) base = np.hypot(x, y) ims = [] for add in np.arange(15): ims.append((plt.pcolor(x, y, base + add, norm=plt.Normalize(0, 30)),)) im_ani = animation.ArtistAnimation(fig2, ims, interval=50, repeat_delay=3000, blit=True) im_ani Your browser does not support the video tag. 通过继承构建 matplotlib.animation.TimedAnimation是上面俩的基类,我们也可以直接继承它来构造动画,主要要重载的是 __init__()方法 _draw_frame方法,对应func new_frame_seq对应frames _init_draw对应init_func from matplotlib.lines import Line2D class SubplotAnimation(animation.TimedAnimation): def __init__(self): fig = plt.figure() ax1 = fig.add_subplot(1, 2, 1) ax2 = fig.add_subplot(2, 2, 2) ax3 = fig.add_subplot(2, 2, 4) self.t = np.linspace(0, 80, 400) self.x = np.cos(2 * np.pi * self.t / 10.) self.y = np.sin(2 * np.pi * self.t / 10.) self.z = 10 * self.t ax1.set_xlabel('x') ax1.set_ylabel('y') self.line1 = Line2D([], [], color='black') self.line1a = Line2D([], [], color='red', linewidth=2) self.line1e = Line2D( [], [], color='red', marker='o', markeredgecolor='r') ax1.add_line(self.line1) ax1.add_line(self.line1a) ax1.add_line(self.line1e) ax1.set_xlim(-1, 1) ax1.set_ylim(-2, 2) ax1.set_aspect('equal', 'datalim') ax2.set_xlabel('y') ax2.set_ylabel('z') self.line2 = Line2D([], [], color='black') self.line2a = Line2D([], [], color='red', linewidth=2) self.line2e = Line2D( [], [], color='red', marker='o', markeredgecolor='r') ax2.add_line(self.line2) ax2.add_line(self.line2a) ax2.add_line(self.line2e) ax2.set_xlim(-1, 1) ax2.set_ylim(0, 800) ax3.set_xlabel('x') ax3.set_ylabel('z') self.line3 = Line2D([], [], color='black') self.line3a = Line2D([], [], color='red', linewidth=2) self.line3e = Line2D( [], [], color='red', marker='o', markeredgecolor='r') ax3.add_line(self.line3) ax3.add_line(self.line3a) ax3.add_line(self.line3e) ax3.set_xlim(-1, 1) ax3.set_ylim(0, 800) animation.TimedAnimation.__init__(self, fig, interval=50, blit=True) def _draw_frame(self, framedata): i = framedata head = i - 1 head_len = 10 head_slice = (self.t > self.t[i] - 1.0) & (self.t ani = SubplotAnimation() ani Your browser does not support the video tag. 动画的输出 最简单的输出就是直接通过matplotlib输出,直接plt.show()即可,注意这种方式jupyter notebook并不支持.只能在脚本中使用 输出为html5可读的视屏 使用.to_html5_video()方法可以直接输出一段浏览器可以识别的带标签的html5字符串这种可以直接嵌入到网页前端 保存动画 动画保存是通过.save(filename, writer=None, fps=None, dpi=None, codec=None, bitrate=None, extra_args=None, metadata=None, extra_anim=None, savefig_kwargs=None)方法 writer可以自己定义转码工具,默认为ffmpeg fps为帧率 dpi控制动画每帧中的每英寸点数. codec指定保存的格式,默认使用filename的后缀作为格式 bitrate指定压缩影片每秒使用的位数，以千位/秒为单位。更高的数字意味着更高质量的电影，但是以增加的文件大小为代价。如果未指定值，则默认值为rcparam animation.bitrate给出的值。 metadata元数据包括在输出文件中的元数据的键和值的字典。可能有用的一些键包括：标题，艺术家，流派，主题，版权，srcform，注释。 动画生成和转码工具的设置 matplotlib本身就是个作图的工具,本身无法制作动画,但他可以通过其他工具提供了几个参数用来转码和设置,我们可以定义一个主题来实现需要的时候加载 animation.ffmpeg_path : /bin/ffmpeg animation.convert_path: /imagemagick/6.9.7-0/bin/convert animation.html: html5 通过这样的设置可以使用ffmpeg工具转码为常见的格式如MP4,也可以通过指定writer参数来使用imagemagick构建gif动画图片. 第三个参数是为了让jupyter notebook可以直接显示动画,如果不设置也可以使用 from IPython.display import HTML 然后HTML(ani.to_html5())来输出动画 Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-18 16:42:44 "},"matplotlib/widgets.html":{"url":"matplotlib/widgets.html","title":"matplotlib控件与交互","keywords":"","body":"控件 很神奇的,matplot还提供了简单的可供交互的控件包括 buttons 按钮 check_buttons 选择按钮 radio_buttons 多选按钮 menu 目录 from __future__ import print_function from imp import reload import matplotlib reload(matplotlib) matplotlib.use('nbagg') import matplotlib.backends.backend_nbagg reload(matplotlib.backends.backend_nbagg) import matplotlib.backends.backend_webagg_core reload(matplotlib.backends.backend_webagg_core) import numpy as np import matplotlib.pyplot as plt plt.interactive(False) 按钮bottom 添加按钮可以使用plt.subplots_adjust(bottom=xx)为其在底部留下足够空间 用plt.axes([0.7, 0.05, 0.1, 0.075])为按钮划定大小和位置 添加按钮可以使用Button(ax, label, image=None, color='0.85', hovercolor='0.95') 而为其添加回调函数,则可以用为其绑定on_clicked方法 bnext = Button(axnext, 'Next') bnext.on_clicked(callback.next) 这种形式 from matplotlib.widgets import Button freqs = np.arange(2, 20, 3) fig, ax = plt.subplots() plt.subplots_adjust(bottom=0.2) t = np.arange(0.0, 1.0, 0.001) s = np.sin(2*np.pi*freqs[0]*t) l, = plt.plot(t, s, lw=2) class Index(object): ind = 0 def next(self, event): self.ind += 1 i = self.ind % len(freqs) ydata = np.sin(2*np.pi*freqs[i]*t) l.set_ydata(ydata) plt.draw() def prev(self, event): self.ind -= 1 i = self.ind % len(freqs) ydata = np.sin(2*np.pi*freqs[i]*t) l.set_ydata(ydata) plt.draw() callback = Index() axprev = plt.axes([0.7, 0.05, 0.1, 0.075]) axnext = plt.axes([0.81, 0.05, 0.1, 0.075]) bnext = Button(axnext, 'Next') bnext.on_clicked(callback.next) bprev = Button(axprev, 'Previous') bprev.on_clicked(callback.prev) plt.show() 选择按钮CheckButtons from matplotlib.widgets import CheckButtons t = np.arange(0.0, 2.0, 0.01) s0 = np.sin(2*np.pi*t) s1 = np.sin(4*np.pi*t) s2 = np.sin(6*np.pi*t) fig, ax = plt.subplots() l0, = ax.plot(t, s0, visible=False, lw=2) l1, = ax.plot(t, s1, lw=2) l2, = ax.plot(t, s2, lw=2) plt.subplots_adjust(left=0.2) rax = plt.axes([0.05, 0.4, 0.1, 0.15]) check = CheckButtons(rax, ('2 Hz', '4 Hz', '6 Hz'), (False, True, True)) def func(label): if label == '2 Hz': l0.set_visible(not l0.get_visible()) elif label == '4 Hz': l1.set_visible(not l1.get_visible()) elif label == '6 Hz': l2.set_visible(not l2.get_visible()) plt.draw() check.on_clicked(func) plt.show() 单选框RadioButtons from matplotlib.widgets import RadioButtons t = np.arange(0.0, 2.0, 0.01) s0 = np.sin(2*np.pi*t) s1 = np.sin(4*np.pi*t) s2 = np.sin(8*np.pi*t) fig, ax = plt.subplots() l, = ax.plot(t, s0, lw=2, color='red') plt.subplots_adjust(left=0.3) axcolor = 'lightgoldenrodyellow' rax = plt.axes([0.05, 0.7, 0.15, 0.15], axisbg=axcolor) radio = RadioButtons(rax, ('2 Hz', '4 Hz', '8 Hz')) def hzfunc(label): hzdict = {'2 Hz': s0, '4 Hz': s1, '8 Hz': s2} ydata = hzdict[label] l.set_ydata(ydata) plt.draw() radio.on_clicked(hzfunc) rax = plt.axes([0.05, 0.4, 0.15, 0.15], axisbg=axcolor) radio2 = RadioButtons(rax, ('red', 'blue', 'green')) def colorfunc(label): l.set_color(label) plt.draw() radio2.on_clicked(colorfunc) rax = plt.axes([0.05, 0.1, 0.15, 0.15], axisbg=axcolor) radio3 = RadioButtons(rax, ('-', '--', '-.', 'steps', ':')) def stylefunc(label): l.set_linestyle(label) plt.draw() radio3.on_clicked(stylefunc) plt.show() /Users/huangsizhe/LIB/CONDA/anaconda/lib/python3.6/site-packages/matplotlib/cbook.py:136: MatplotlibDeprecationWarning: The axisbg attribute was deprecated in version 2.0. Use facecolor instead. warnings.warn(message, mplDeprecation, stacklevel=1) 滑块Slider from matplotlib.widgets import Slider, Button, RadioButtons fig, ax = plt.subplots() plt.subplots_adjust(left=0.25, bottom=0.25) t = np.arange(0.0, 1.0, 0.001) a0 = 5 f0 = 3 s = a0*np.sin(2*np.pi*f0*t) l, = plt.plot(t, s, lw=2, color='red') plt.axis([0, 1, -10, 10]) axcolor = 'lightgoldenrodyellow' axfreq = plt.axes([0.25, 0.1, 0.65, 0.03], axisbg=axcolor) axamp = plt.axes([0.25, 0.15, 0.65, 0.03], axisbg=axcolor) sfreq = Slider(axfreq, 'Freq', 0.1, 30.0, valinit=f0) samp = Slider(axamp, 'Amp', 0.1, 10.0, valinit=a0) def update(val): amp = samp.val freq = sfreq.val l.set_ydata(amp*np.sin(2*np.pi*freq*t)) fig.canvas.draw_idle() sfreq.on_changed(update) samp.on_changed(update) resetax = plt.axes([0.8, 0.025, 0.1, 0.04]) button = Button(resetax, 'Reset', color=axcolor, hovercolor='0.975') def reset(event): sfreq.reset() samp.reset() button.on_clicked(reset) rax = plt.axes([0.025, 0.5, 0.15, 0.15], axisbg=axcolor) radio = RadioButtons(rax, ('red', 'blue', 'green'), active=0) def colorfunc(label): l.set_color(label) fig.canvas.draw_idle() radio.on_clicked(colorfunc) plt.show() /Users/huangsizhe/LIB/CONDA/anaconda/lib/python3.6/site-packages/matplotlib/cbook.py:136: MatplotlibDeprecationWarning: The axisbg attribute was deprecated in version 2.0. Use facecolor instead. warnings.warn(message, mplDeprecation, stacklevel=1) 光标Cursor from matplotlib.widgets import Cursor fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, axisbg='#FFFFCC') x, y = 4*(np.random.rand(2, 100) - .5) ax.plot(x, y, 'o') ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) # set useblit = True on gtkagg for enhanced performance cursor = Cursor(ax, useblit=True, color='red', linewidth=2) plt.show() /Users/huangsizhe/LIB/CONDA/anaconda/lib/python3.6/site-packages/matplotlib/cbook.py:136: MatplotlibDeprecationWarning: The axisbg attribute was deprecated in version 2.0. Use facecolor instead. warnings.warn(message, mplDeprecation, stacklevel=1) 多路光标 from matplotlib.widgets import MultiCursor t = np.arange(0.0, 2.0, 0.01) s1 = np.sin(2*np.pi*t) s2 = np.sin(4*np.pi*t) fig = plt.figure() ax1 = fig.add_subplot(211) ax1.plot(t, s1) ax2 = fig.add_subplot(212, sharex=ax1) ax2.plot(t, s2) multi = MultiCursor(fig.canvas, (ax1, ax2), color='r', lw=1) plt.show() 矩形框 from matplotlib.widgets import RectangleSelector def line_select_callback(eclick, erelease): 'eclick and erelease are the press and release events' x1, y1 = eclick.xdata, eclick.ydata x2, y2 = erelease.xdata, erelease.ydata print(\"(%3.2f, %3.2f) --> (%3.2f, %3.2f)\" % (x1, y1, x2, y2)) print(\" The button you used were: %s %s\" % (eclick.button, erelease.button)) def toggle_selector(event): print(' Key pressed.') if event.key in ['Q', 'q'] and toggle_selector.RS.active: print(' RectangleSelector deactivated.') toggle_selector.RS.set_active(False) if event.key in ['A', 'a'] and not toggle_selector.RS.active: print(' RectangleSelector activated.') toggle_selector.RS.set_active(True) fig, current_ax = plt.subplots() # make a new plotingrange N = 100000 # If N is large one can see x = np.linspace(0.0, 10.0, N) # improvement by use blitting! plt.plot(x, +np.sin(.2*np.pi*x), lw=3.5, c='b', alpha=.7) # plot something plt.plot(x, +np.cos(.2*np.pi*x), lw=3.5, c='r', alpha=.5) plt.plot(x, -np.sin(.2*np.pi*x), lw=3.5, c='g', alpha=.3) print(\"\\n click --> release\") # drawtype is 'box' or 'line' or 'none' toggle_selector.RS = RectangleSelector(current_ax, line_select_callback, drawtype='box', useblit=True, button=[1, 3], # don't use middle button minspanx=5, minspany=5, spancoords='pixels', interactive=True) plt.connect('key_press_event', toggle_selector) plt.show() click --> release 选定区域SpanSelector from matplotlib.widgets import SpanSelector fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(211, axisbg='#FFFFCC') x = np.arange(0.0, 5.0, 0.01) y = np.sin(2*np.pi*x) + 0.5*np.random.randn(len(x)) ax.plot(x, y, '-') ax.set_ylim(-2, 2) ax.set_title('Press left mouse button and drag to test') ax2 = fig.add_subplot(212, axisbg='#FFFFCC') line2, = ax2.plot(x, y, '-') def onselect(xmin, xmax): indmin, indmax = np.searchsorted(x, (xmin, xmax)) indmax = min(len(x) - 1, indmax) thisx = x[indmin:indmax] thisy = y[indmin:indmax] line2.set_data(thisx, thisy) ax2.set_xlim(thisx[0], thisx[-1]) ax2.set_ylim(thisy.min(), thisy.max()) fig.canvas.draw() # set useblit True on gtkagg for enhanced performance span = SpanSelector(ax, onselect, 'horizontal', useblit=True, rectprops=dict(alpha=0.5, facecolor='red')) plt.show() /Users/huangsizhe/LIB/CONDA/anaconda/lib/python3.6/site-packages/matplotlib/cbook.py:136: MatplotlibDeprecationWarning: The axisbg attribute was deprecated in version 2.0. Use facecolor instead. warnings.warn(message, mplDeprecation, stacklevel=1) Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-18 17:27:58 "},"matplotlib/finance/finance.html":{"url":"matplotlib/finance/finance.html","title":"金融信息爬取","keywords":"","body":"finance模块 matplotlib.finance是matplotlib包中唯一和图形图像没啥关系的一个模块 它可以用于收集，分析和绘制财务数据的功能集合 import matplotlib.pyplot as plt from matplotlib.finance import quotes_historical_yahoo_ochl ,fetch_historical_yahoo,quotes_historical_yahoo_ohlc from matplotlib.dates import YearLocator, MonthLocator, DateFormatter ,WeekdayLocator,MONDAY,DayLocator from matplotlib.finance import parse_yahoo_historical_ochl,parse_yahoo_historical_ohlc import datetime import numpy as np /Users/huangsizhe/LIB/CONDA/anaconda/lib/python3.6/site-packages/matplotlib/cbook.py:136: MatplotlibDeprecationWarning: The finance module has been deprecated in mpl 2.0 and will be removed in mpl 2.2. Please use the module mpl_finance instead. warnings.warn(message, mplDeprecation, stacklevel=1) %matplotlib inline plt.style.use('chinese_support') 数据获取: matplotlib.finance.fetch_historical_yahoo(ticker, date1, date2, cachename=None, dividends=False) 在date1和date2之间获取代码的历史数据。date1和date2是日期或datetime实例，或（年，月，日）序列。 其中dividends = True则返回股息而不是价格数据。使用此选项设置，解析函数将不工作.它返回一个打开的file对象,以标普500为例 with fetch_historical_yahoo('^GSPC', (2000, 1, 1), (2001, 12, 31)) as fh: print(fh.readlines()[:5]) ['Date,Open,High,Low,Close,Volume,Adj Close\\n', '2001-12-31,1161.02002,1161.160034,1148.040039,1148.079956,943600000,1148.079956\\n', '2001-12-28,1157.130005,1164.640015,1157.130005,1161.02002,917400000,1161.02002\\n', '2001-12-27,1149.369995,1157.130005,1149.369995,1157.130005,876300000,1157.130005\\n', '2001-12-26,1144.650024,1159.180054,1144.650024,1149.369995,791100000,1149.369995\\n'] 因为获取的是文件类型,finance模块还提供了解析工具 matplotlib.finance.parse_yahoo_historical_ohlc(fh, adjusted=True, asobject=False) 输出对应(时间戳,开市,最高,最低,闭市,成交量) matplotlib.finance.parse_yahoo_historical_ochl(fh, adjusted=True, asobject=False) 输出对应(时间戳,开市,闭市,最高,最低,成交量) with fetch_historical_yahoo('^GSPC', (2015, 12, 20), (2016, 12, 20)) as fh: print(parse_yahoo_historical_ohlc(fh)[:5]) [(735953.0, 2010.2700199999999, 2022.900024, 2005.9300539999999, 2021.150024, 3760280000.0), (735954.0, 2023.150024, 2042.73999, 2020.48999, 2038.969971, 3520860000.0), (735955.0, 2042.1999510000001, 2064.7299800000001, 2042.1999510000001, 2064.290039, 3484090000.0), (735956.0, 2063.5200199999999, 2067.360107, 2058.7299800000001, 2060.98999, 1411860000.0), (735960.0, 2057.7700199999999, 2057.7700199999999, 2044.1999510000001, 2056.5, 2492510000.0)] with fetch_historical_yahoo('^GSPC', (2015, 12, 20), (2016, 12, 20)) as fh: print(parse_yahoo_historical_ochl(fh)[:5]) [(735953.0, 2010.2700199999999, 2021.150024, 2022.900024, 2005.9300539999999, 3760280000.0), (735954.0, 2023.150024, 2038.969971, 2042.73999, 2020.48999, 3520860000.0), (735955.0, 2042.1999510000001, 2064.290039, 2064.7299800000001, 2042.1999510000001, 3484090000.0), (735956.0, 2063.5200199999999, 2060.98999, 2067.360107, 2058.7299800000001, 1411860000.0), (735960.0, 2057.7700199999999, 2056.5, 2057.7700199999999, 2044.1999510000001, 2492510000.0)] 而下两个则是直接返回解析好的结果 matplotlib.finance.quotes_historical_yahoo_ochl(ticker, date1, date2, asobject=False, adjusted=True, cachename=None) matplotlib.finance.quotes_historical_yahoo_ohlc(ticker, date1, date2, asobject=False, adjusted=True, cachename=None) quotes_historical_yahoo_ochl('^GSPC', (2015, 12, 20), (2016, 12, 20))[:2] [(735953.0, 2010.2700199999999, 2021.150024, 2022.900024, 2005.9300539999999, 3760280000.0), (735954.0, 2023.150024, 2038.969971, 2042.73999, 2020.48999, 3520860000.0)] quotes_historical_yahoo_ohlc('^GSPC', (2015, 12, 20), (2016, 12, 20))[:2] [(735953.0, 2010.2700199999999, 2022.900024, 2005.9300539999999, 2021.150024, 3760280000.0), (735954.0, 2023.150024, 2042.73999, 2020.48999, 2038.969971, 3520860000.0)] 绘制k线图 以价格为参数的方法 matplotlib.finance.candlestick2_ochl(ax, opens, closes, highs, lows, width=4, colorup='k', colordown='r', alpha=0.75) 输入对应(时间戳,开市,闭市,最高,最低,成交量) matplotlib.finance.candlestick2_ohlc(ax, opens, highs, lows, closes, width=4, colorup='k', colordown='r', alpha=0.75) 输入对应(时间戳,开市,最高,最低,闭市,成交量) 以解析出来的原始序列为参数 matplotlib.finance.candlestick_ochl(ax, quotes, width=0.2, colorup='k', colordown='r', alpha=1.0) 输入对应(时间戳,开市,闭市,最高,最低,成交量) matplotlib.finance.candlestick_ohlc(ax, quotes, width=0.2, colorup='k', colordown='r', alpha=1.0) 输入对应(时间戳,开市,最高,最低,闭市,成交量) from matplotlib.finance import candlestick2_ochl,candlestick2_ohlc,candlestick_ochl,candlestick_ohlc #设置x轴坐标刻度 mondays = WeekdayLocator(MONDAY) # 主要刻度 alldays = DayLocator() # 次要刻度 mondayFormatter = DateFormatter('%m-%d-%Y') # 如：2-29-2015 dayFormatter = DateFormatter('%d') # 数据处理 quotes_ochl = quotes_historical_yahoo_ochl('^GSPC', (2015, 12, 20), (2016, 6, 20)) ochl = np.array(quotes_ochl).T[1:-1] quotes_ohlc = quotes_historical_yahoo_ohlc('^GSPC', (2015, 12, 20), (2016, 6, 20)) ohlc = np.array(quotes_ohlc).T[1:-1] # 设置x坐标轴 fig, ax = plt.subplots() fig.subplots_adjust(bottom=0.2) ax.xaxis.set_major_locator(mondays) ax.xaxis.set_minor_locator(alldays) ax.xaxis.set_major_formatter(mondayFormatter) # 绘制图形 candlestick_ohlc(ax, quotes_ohlc, width=0.6, colorup='r', colordown='g') ax.xaxis_date() ax.autoscale_view() plt.setp(plt.gca().get_xticklabels(), rotation=45, horizontalalignment='right') ax.grid(True) plt.title(u'标普500') plt.show() # 设置x坐标轴 fig, ax = plt.subplots() fig.subplots_adjust(bottom=0.2) ax.xaxis.set_major_locator(mondays) ax.xaxis.set_minor_locator(alldays) ax.xaxis.set_major_formatter(mondayFormatter) # 绘制图形 o,h,l,c = ohlc candlestick2_ohlc(ax, o,h,l,c , width=0.6, colorup='r', colordown='g') ax.xaxis_date() ax.autoscale_view() plt.setp(plt.gca().get_xticklabels(), rotation=45, horizontalalignment='right') ax.grid(True) plt.title(u'标普500') plt.show() 绘制天的数据 这种图的上下柱是交易的最高最低值,而侧柱则表示开盘价和收盘价 以价格为参数的方法 matplotlib.finance.plot_day_summary2_ochl(ax, opens, closes, highs, lows, ticksize=4, colorup='k', colordown='r') matplotlib.finance.plot_day_summary2_ohlc(ax, opens, highs, lows, closes, ticksize=4, colorup='k', colordown='r') 以解析出来的原始序列为参数 matplotlib.finance.plot_day_summary_oclh(ax, quotes, ticksize=3, colorup='k', colordown='r') matplotlib.finance.plot_day_summary_ohlc(ax, quotes, ticksize=3, colorup='k', colordown='r') from matplotlib.finance import plot_day_summary_oclh # 设置x坐标轴 fig, ax = plt.subplots() fig.subplots_adjust(bottom=0.2) ax.xaxis.set_major_locator(mondays) ax.xaxis.set_minor_locator(alldays) ax.xaxis.set_major_formatter(mondayFormatter) plot_day_summary_oclh(ax,quotes_ochl[:7], ticksize= 10,colorup='r', colordown='g') ax.xaxis_date() ax.autoscale_view() #plt.setp(plt.gca().get_xticklabels(), rotation=45, horizontalalignment='right') ax.grid(True) plt.title(u'标普500') plt.show() 成交量相关的图形 matplotlib.finance.index_bar(ax, vals, facecolor='b', edgecolor='l', width=4, alpha=1.0) matplotlib.finance.volume_overlay(ax, opens, closes, volumes, colorup='k', colordown='r', width=4, alpha=1.0) matplotlib.finance.volume_overlay2(ax, closes, volumes, colorup='k', colordown='r', width=4, alpha=1.0) matplotlib.finance.volume_overlay3(ax, quotes, colorup='k', colordown='r', width=4, alpha=1.0) from matplotlib.finance import index_bar,volume_overlay3 volume = np.array(quotes_ochl).T[-1]/10000000000 #fig = plt.figure(figsize=(12,16)) fig ,subplots=plt.subplots(3,1) plt.title(u'标普500') fig.set_size_inches((12,16)) for i,ax in enumerate(subplots): ax.xaxis.set_major_locator(mondays) ax.xaxis.set_minor_locator(alldays) ax.xaxis.set_major_formatter(mondayFormatter) if i == 0: ax.set_ylabel(u'价格') candlestick_ohlc(ax, quotes_ohlc, width=0.6, colorup='r', colordown='g') elif i ==1: ax.set_ylabel(u'成交量') index_bar(ax,volume,facecolor='b', edgecolor='r') else: ax.set_ylabel(u'成交量面积') ax.set_ylim((0, 1e10)) v = volume_overlay3(ax, quotes_ohlc) ax.xaxis_date() ax.autoscale_view() plt.setp(plt.gca().get_xticklabels(), rotation=45, horizontalalignment='right') ax.grid(True) plt.show() Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-06-18 17:08:38 "}}